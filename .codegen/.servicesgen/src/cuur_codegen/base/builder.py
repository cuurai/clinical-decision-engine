"""
Builder Protocol and Base Class - Standardized builder pattern with enhanced features

Enhanced with:
- Configuration support
- Template rendering utilities
- Common code generation patterns
- Error handling
"""

from typing import Protocol, Optional, Dict, Any, List
from pathlib import Path
from cuur_codegen.core.context import GenerationContext
from cuur_codegen.core.errors import GenerationError


class Builder(Protocol):
    """Protocol for all builders - defines the contract builders must follow"""

    def build(self, context: GenerationContext, **kwargs) -> str:
        """
        Build content from context.

        Args:
            context: Generation context
            **kwargs: Additional builder-specific arguments

        Returns:
            Generated content as string
        """
        ...


class BaseBuilder:
    """Base class for builders with common utilities and configuration support"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize builder with optional configuration.

        Args:
            config: Optional builder-specific configuration
        """
        self.config = config or {}

    @staticmethod
    def generate_header(
        context: GenerationContext,
        description: str,
        generator_name: Optional[str] = None,
        version: Optional[str] = None,
        additional_info: Optional[List[str]] = None,
    ) -> str:
        """
        Generate a standard file header comment.

        Args:
            context: Generation context
            description: Description for the header
            generator_name: Optional generator name (uses context if not provided)
            version: Optional version (uses context config version if not provided)
            additional_info: Optional list of additional info lines

        Returns:
            Header comment string
        """
        generator = generator_name or "Builder"
        ver = version or context.config.version or "1.0.0"

        lines = [
            f"/**",
            f" * {description}",
            f" *",
            f" * Generated by {generator} v{ver}",
            f" * Domain: {context.domain_name}",
        ]

        if additional_info:
            for info in additional_info:
                lines.append(f" * {info}")

        lines.extend([
            f" *",
            f" * ⚠️  DO NOT EDIT THIS FILE MANUALLY",
            f" * This file is auto-generated. Any manual changes will be overwritten.",
            f" */",
            "",
        ])

        return "\n".join(lines)

    @staticmethod
    def indent(content: str, level: int = 1, indent_str: str = "  ") -> str:
        """
        Indent content by a specified number of levels.

        Args:
            content: Content to indent
            level: Number of indentation levels
            indent_str: String to use for each level (default: 2 spaces)

        Returns:
            Indented content
        """
        indent = indent_str * level
        lines = content.split("\n")
        indented_lines = [f"{indent}{line}" if line.strip() else line for line in lines]
        return "\n".join(indented_lines)

    @staticmethod
    def format_imports(imports: List[str], sort: bool = True) -> str:
        """
        Format import statements.

        Args:
            imports: List of import statements
            sort: Whether to sort imports (default: True)

        Returns:
            Formatted import block
        """
        if sort:
            imports = sorted(imports)

        if not imports:
            return ""

        return "\n".join(imports) + "\n"

    @staticmethod
    def format_exports(exports: List[str], sort: bool = True) -> str:
        """
        Format export statements.

        Args:
            exports: List of export statements
            sort: Whether to sort exports (default: True)

        Returns:
            Formatted export block
        """
        if sort:
            exports = sorted(exports)

        if not exports:
            return ""

        return "\n".join(exports) + "\n"

    def get_config(self, key: str, default: Any = None) -> Any:
        """
        Get configuration value.

        Args:
            key: Configuration key (supports dot notation for nested keys)
            default: Default value if key not found

        Returns:
            Configuration value or default
        """
        keys = key.split(".")
        value = self.config

        for k in keys:
            if isinstance(value, dict):
                value = value.get(k)
                if value is None:
                    return default
            else:
                return default

        return value if value is not None else default

    def validate_required_config(self, keys: List[str]) -> None:
        """
        Validate that required configuration keys are present.

        Args:
            keys: List of required configuration keys

        Raises:
            GenerationError: If any required key is missing
        """
        missing = []
        for key in keys:
            if self.get_config(key) is None:
                missing.append(key)

        if missing:
            raise GenerationError(f"Missing required configuration keys: {', '.join(missing)}")
