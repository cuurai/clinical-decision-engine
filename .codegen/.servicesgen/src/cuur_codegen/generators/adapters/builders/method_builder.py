"""
Method Builder

Builds repository method implementations
"""

import re
from typing import List, Optional, Set
from .repository_discovery import RepositoryInfo


class MethodBuilder:
    """Builds repository method implementations"""

    @staticmethod
    def _extract_entity_fields(entity_name: str, spec: Optional[dict] = None) -> Set[str]:
        """
        Extract field names from entity schema in OpenAPI spec.

        Returns set of field names (e.g., {"id", "orgId", "status", "latencyMs", "createdAt", "updatedAt"})
        """
        if not spec or not isinstance(spec, dict):
            return set()

        schemas = spec.get("components", {}).get("schemas", {})
        if not isinstance(schemas, dict):
            return set()

        entity_schema = schemas.get(entity_name)
        if not isinstance(entity_schema, dict):
            return set()

        properties = entity_schema.get("properties", {})
        if not isinstance(properties, dict):
            return set()

        # Extract all property names
        field_names = set()
        for prop_name in properties.keys():
            if isinstance(prop_name, str):
                field_names.add(prop_name)

        return field_names

    @staticmethod
    def _build_select_clause(fields: Set[str]) -> str:
        """
        Build Prisma select clause from field names.

        ARCHITECTURAL DECISION: Select clause is NOT generated by default.
        This ensures safety (no missing fields) and allows developers to
        explicitly optimize queries when needed.

        Returns empty string (no select clause) - developers can add manually.
        """
        # Return empty string - no select clause by default
        # Developers can add select clauses manually for optimization
        return ""

    @staticmethod
    def build_methods(repo: RepositoryInfo, entity_fields: Optional[Set[str]] = None) -> List[str]:
        """Build repository methods"""
        methods = []
        entity_pascal = repo.entity_name
        create_type = repo.create_type or f"Create{entity_pascal}Request"
        update_type = repo.update_type or f"Update{entity_pascal}Request"
        list_params_type = repo.list_params_type_full or repo.list_params_type or "PaginationParams"

        # Determine orgId type usage
        has_any_explicit_string_org_id = (
            repo.uses_string_for_org_id.get('create', False) or
            repo.uses_string_for_org_id.get('update', False) or
            repo.uses_string_for_org_id.get('delete', False)
        )

        # List method with selective fields for better performance and soft delete filtering
        org_id_type_list = 'string' if repo.uses_string_for_org_id.get('list', False) else 'OrgId'
        select_clause = MethodBuilder._build_select_clause(entity_fields) if entity_fields else ""
        list_method = f"""  async list(
    orgId: {org_id_type_list},
    params?: {list_params_type}
  ): Promise<PaginatedResult<{entity_pascal}>> {{
    try {{
      const limit = params?.limit ?? DEFAULT_LIMIT;

      const records = await this.dao.{repo.name}.findMany({{
        where: {{
          orgId,
          deletedAt: null, // Soft delete filter - only return non-deleted records
        }},
        orderBy: {{ createdAt: "desc" }},
        take: limit,{select_clause}
        ...(params?.cursor ? {{
          skip: 1,
          cursor: {{ id: params.cursor }},
        }} : {{}}),
      }});

      return {{
        items: records.map((r) => this.toDomain(r)),
        nextCursor: records.length === limit
          ? records[records.length - 1]?.id
          : undefined,
        prevCursor: undefined,
      }};
    }} catch (error) {{
      handleDatabaseError(error);
      throw error;
    }}
  }}"""
        methods.append(list_method)

        # findById method with selective fields and soft delete filtering
        org_id_type_find_by_id = 'string' if repo.uses_string_for_org_id.get('findById', False) else 'OrgId'
        select_clause_find = MethodBuilder._build_select_clause(entity_fields) if entity_fields else ""
        find_by_id_method = f"""  async findById(orgId: {org_id_type_find_by_id}, id: string): Promise<{entity_pascal} | null> {{
    try {{
      const record = await this.dao.{repo.name}.findFirst({{
        where: {{
          orgId,
          id,
          deletedAt: null, // Soft delete filter - only return non-deleted records
        }},{select_clause_find}
      }});
      return record ? this.toDomain(record) : null;
    }} catch (error) {{
      handleDatabaseError(error);
      throw error;
    }}
  }}"""
        methods.append(find_by_id_method)

        # get method - throws NotFoundError if not found
        org_id_type_get = 'string' if repo.uses_string_for_org_id.get('get', False) else 'OrgId'
        get_method = f"""  async get(orgId: {org_id_type_get}, id: string): Promise<{entity_pascal} | null> {{
    const result = await this.findById(orgId, id);
    if (!result) {{
      throw new NotFoundError("{entity_pascal}", id);
    }}
    return result;
  }}"""
        methods.append(get_method)

        # create method with audit trail support
        if repo.has_create or repo.is_crud:
            create_param_type = repo.create_type_full or create_type
            org_id_type_create = 'string' if (repo.uses_string_for_org_id.get('create', False) or has_any_explicit_string_org_id) else 'OrgId'
            create_method = f"""  async create(orgId: {org_id_type_create}, data: {create_param_type}, createdBy?: string): Promise<{entity_pascal}> {{
    try {{
      const record = await this.dao.{repo.name}.create({{
        data: {{
          ...data,
          orgId, // Set orgId after spread to ensure it's always set correctly
          createdBy: createdBy ?? null, // Audit trail
        }},
      }});
      return this.toDomain(record);
    }} catch (error) {{
      handleDatabaseError(error);
      throw error;
    }}
  }}"""
            methods.append(create_method)

        # update method with error handling and audit trail support
        if repo.has_update or repo.is_crud:
            update_param_type = repo.update_type_full or update_type
            org_id_type_update = 'string' if (repo.uses_string_for_org_id.get('update', False) or has_any_explicit_string_org_id) else 'OrgId'
            if repo.update_has_id:
                update_method = f"""  async update(orgId: {org_id_type_update}, id: string, data: {update_param_type}, updatedBy?: string): Promise<{entity_pascal}> {{
    try {{
      const record = await this.dao.{repo.name}.update({{
        where: {{ id }},
        data: {{
          ...data,
          updatedBy: updatedBy ?? null, // Audit trail
        }},
      }});
      return this.toDomain(record);
    }} catch (error) {{
      handleDatabaseError(error);
      throw error;
    }}
  }}"""
                methods.append(update_method)
            else:
                update_method_no_id = f"""  async update(orgId: {org_id_type_update}, data: {update_param_type}, updatedBy?: string): Promise<{entity_pascal}> {{
    try {{
      const record = await this.dao.{repo.name}.update({{
        where: {{ orgId }},
        data: {{
          ...data,
          updatedBy: updatedBy ?? null, // Audit trail
        }},
      }});
      return this.toDomain(record);
    }} catch (error) {{
      handleDatabaseError(error);
      throw error;
    }}
  }}"""
                methods.append(update_method_no_id)

        # delete method with soft delete support (sets deletedAt instead of hard delete)
        if repo.has_delete:
            org_id_type_delete = 'string' if (repo.uses_string_for_org_id.get('delete', False) or has_any_explicit_string_org_id) else 'OrgId'
            delete_method = f"""  async delete(orgId: {org_id_type_delete}, id: string, deletedBy?: string): Promise<void> {{
    try {{
      // Soft delete: set deletedAt instead of hard delete
      await this.dao.{repo.name}.update({{
        where: {{ id }},
        data: {{
          deletedAt: new Date(),
          deletedBy: deletedBy ?? null,
        }},
      }});
    }} catch (error) {{
      handleDatabaseError(error);
      throw error;
    }}
  }}"""
            methods.append(delete_method)

        # Batch operations for better performance
        if repo.has_create or repo.is_crud:
            create_param_type = repo.create_type_full or create_type
            org_id_type_create = 'string' if (repo.uses_string_for_org_id.get('create', False) or has_any_explicit_string_org_id) else 'OrgId'
            # createMany method - optimized batch creation
            create_many_method = f"""  async createMany(orgId: {org_id_type_create}, items: Array<{create_param_type}>): Promise<{entity_pascal}[]> {{
    try {{
      // Use createMany for better performance
      await this.dao.{repo.name}.createMany({{
        data: items.map(item => ({{
          ...item,
          orgId,
        }})),
        skipDuplicates: true,
      }});

      // Fetch created records
      const ids = items.map(item => item.id).filter(Boolean) as string[];
      if (ids.length === 0) {{
        return [];
      }}

      const records = await this.dao.{repo.name}.findMany({{
        where: {{ id: {{ in: ids }}, orgId }},
      }});

      return records.map((r) => this.toDomain(r));
    }} catch (error) {{
      handleDatabaseError(error);
      throw error;
    }}
  }}"""
            methods.append(create_many_method)

        if repo.has_update or repo.is_crud:
            update_param_type = repo.update_type_full or update_type
            org_id_type_update = 'string' if (repo.uses_string_for_org_id.get('update', False) or has_any_explicit_string_org_id) else 'OrgId'
            # updateMany method - optimized batch updates
            update_many_method = f"""  async updateMany(orgId: {org_id_type_update}, updates: Array<{{ id: string; data: {update_param_type} }}>): Promise<{entity_pascal}[]> {{
    try {{
      // Use transaction for atomic batch updates
      return await this.transactionManager.execute(orgId, async (tx) => {{
        const results: {entity_pascal}[] = [];
        for (const {{ id, data }} of updates) {{
          const record = await tx.{repo.name}.update({{
            where: {{ id }},
            data,
          }});
          results.push(this.toDomain(record));
        }}
        return results;
      }});
    }} catch (error) {{
      handleDatabaseError(error);
      throw error;
    }}
  }}"""
            methods.append(update_many_method)

        if repo.has_delete:
            org_id_type_delete = 'string' if (repo.uses_string_for_org_id.get('delete', False) or has_any_explicit_string_org_id) else 'OrgId'
            # deleteMany method - optimized batch soft deletes
            delete_many_method = f"""  async deleteMany(orgId: {org_id_type_delete}, ids: string[], deletedBy?: string): Promise<void> {{
    try {{
      // Soft delete: set deletedAt for multiple records
      await this.dao.{repo.name}.updateMany({{
        where: {{
          id: {{ in: ids }},
          orgId,
        }},
        data: {{
          deletedAt: new Date(),
          deletedBy: deletedBy ?? null,
        }},
      }});
    }} catch (error) {{
      handleDatabaseError(error);
      throw error;
    }}
  }}"""
            methods.append(delete_many_method)

        # Custom methods
        if repo.custom_methods:
            for custom_method in repo.custom_methods:
                method_sig = custom_method['signature']
                # Extract parameters and return type
                param_match = re.search(r'\(([^)]*)\)', method_sig)
                return_match = re.search(r'Promise<([^>]+)>', method_sig)
                params = param_match.group(1) if param_match else ''
                return_type = return_match.group(1) if return_match else 'void'
                method_name = custom_method['name']

                # Generate stub implementation
                custom_method_code = f"""  async {method_name}({params}): Promise<{return_type}> {{
    // TODO: Implement {method_name} method
    // This is a custom method that needs manual implementation
    throw new Error("Method {method_name} not implemented");
  }}"""
                methods.append(custom_method_code)

        # toDomain method - explicit field mapping for better type safety
        to_domain_method = f"""  private toDomain(model: any): {entity_pascal} {{
    return {{
      ...model,
      createdAt: model.createdAt instanceof Date
        ? model.createdAt
        : new Date(model.createdAt),
      updatedAt: model.updatedAt instanceof Date
        ? model.updatedAt
        : model.updatedAt ? new Date(model.updatedAt) : undefined,
    }} as {entity_pascal};
  }}"""
        methods.append(to_domain_method)

        return methods
