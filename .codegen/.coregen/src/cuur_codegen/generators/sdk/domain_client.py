"""
SDK Domain Client Generator - Generates TypeScript domain client classes

Generates domain client classes that wrap HTTP calls using generated types and schemas.
"""

from pathlib import Path
from typing import Dict, Any, List, Optional

from cuur_codegen.base.generator import BaseGenerator, GenerateResult
from cuur_codegen.base.context import GenerationContext
from cuur_codegen.base.folder_structure import FolderStructureConfig
from cuur_codegen.utils.openapi import (
    extract_operations,
    get_request_body_schema_name,
    get_response_schema_name,
)
from cuur_codegen.utils.string import (
    extract_verb_from_operation_id,
    camel_case,
    pascal_case,
)
from cuur_codegen.utils.naming import NamingConvention
from cuur_codegen.utils.file import ensure_directory, write_file


class DomainClientGenerator(BaseGenerator):
    """Generates SDK domain client classes from OpenAPI operations"""

    @property
    def name(self) -> str:
        return "SDK Domain Client Generator"

    @property
    def version(self) -> str:
        return "1.0.0"

    @property
    def type(self) -> str:
        return "domain_client"

    def generate(self, context: GenerationContext) -> GenerateResult:
        """Generate domain client file"""
        self.validate_context(context)

        files: List[Path] = []
        warnings: List[str] = []

        # Get output directory using FolderStructureConfig
        folder_config = FolderStructureConfig()
        sdk_layer_config = folder_config.get_layer_config("sdk")
        clients_config = sdk_layer_config.get_generator_config("domain_client")

        if not clients_config:
            warnings.append("Domain client generator not configured for SDK layer")
            return GenerateResult(files=files, warnings=warnings)

        project_root = context.config.paths.project_root
        base_path = Path(sdk_layer_config.base_path)
        # Domain clients go in packages/sdk/src/domains, not in generated folder
        output_dir = project_root / "packages" / "sdk" / "src" / "domains"
        ensure_directory(output_dir)

        # Extract operations
        operations = extract_operations(context.spec)
        if not operations:
            warnings.append("No operations found in OpenAPI spec")
            return GenerateResult(files=files, warnings=warnings)

        # Generate domain client file
        client_file = output_dir / f"{context.domain_name}.client.ts"
        client_content = self._generate_domain_client(context, operations)
        write_file(client_file, client_content)
        files.append(client_file)

        return GenerateResult(files=files, warnings=warnings)

    def _generate_domain_client(
        self,
        context: GenerationContext,
        operations: List[Dict[str, Any]]
    ) -> str:
        """Generate domain client class content"""
        domain_name = context.domain_name
        client_class_name = self._get_client_class_name(domain_name)

        # Generate methods for each operation
        methods = []
        for op_data in operations:
            method = self._generate_method(context, op_data)
            if method:
                methods.append(method)

        # Build class content
        header = self._generate_header()
        imports = self._generate_imports()
        class_content = f"""{header}{imports}

/**
 * {client_class_name} domain client
 */
export class {client_class_name} {{
  constructor(private http: HttpClient) {{}}

{chr(10).join(methods)}
}}
"""

        return class_content

    def _generate_header(self) -> str:
        """Generate file header"""
        return """/**
 * SDK Domain Client
 *
 * Generated by SDK Domain Client Generator v1.0.0
 * Generator Version: 1.0.0
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated. Any manual changes will be overwritten.
 */

"""

    def _generate_imports(self) -> str:
        """Generate import statements"""
        # Note: paths type import removed as it's not currently used
        # If needed in future, can be conditionally added
        return """import { HttpClient } from "../http/http-client";
"""

    def _generate_method(
        self,
        context: GenerationContext,
        op_data: Dict[str, Any]
    ) -> str:
        """Generate a method for an operation"""
        operation = op_data["operation"]
        operation_id = op_data["operation_id"]
        path = op_data["path"]
        method = op_data["method"].lower()

        # Get method name from operation ID
        method_name = self._get_method_name(operation_id, method)

        # Get request and response types
        request_type = self._get_request_type(operation, context)
        response_type = self._get_response_type(operation, context, path, method)

        # Build path with parameters
        path_with_params = self._build_path_with_params(path, operation)

        # Generate method signature and body
        if request_type:
            method_signature = f"  async {method_name}({self._get_method_params(operation, request_type)}): Promise<{response_type}>"
        else:
            method_signature = f"  async {method_name}({self._get_method_params(operation, None)}): Promise<{response_type}>"

        method_body = self._build_method_body(method, path_with_params, request_type)

        return f"""{method_signature} {{
{method_body}
  }}
"""

    def _get_client_class_name(self, domain_name: str) -> str:
        """Get client class name from domain name"""
        # Convert domain name to PascalCase and add "Client"
        # e.g., "auth" -> "AuthClient", "e-documents" -> "EDocumentsClient"
        parts = domain_name.split("-")
        pascal_parts = [pascal_case(part) for part in parts]
        return "".join(pascal_parts) + "Client"

    def _get_method_name(self, operation_id: str, http_method: str) -> str:
        """Get method name from operation ID"""
        # Extract verb and resource from operation ID
        # e.g., "createAuthSession" -> "createSession", "listMarkets" -> "list"
        verb = extract_verb_from_operation_id(operation_id)

        # Convert to camelCase
        if verb:
            return camel_case(verb)

        # Fallback to HTTP method
        return camel_case(http_method)

    def _get_request_type(
        self,
        operation: Dict[str, Any],
        context: GenerationContext
    ) -> Optional[str]:
        """Get request body type name"""
        schema_name = get_request_body_schema_name(operation, context.spec)
        return schema_name

    def _get_response_type(
        self,
        operation: Dict[str, Any],
        context: GenerationContext,
        path: str,
        method: str
    ) -> str:
        """Get response type name"""
        # Try to get response schema name
        response_schema = get_response_schema_name(operation, context.spec)
        if response_schema:
            return response_schema

        # Fallback to any for consistency with core generators
        return "any"

    def _build_path_with_params(
        self,
        path: str,
        operation: Dict[str, Any]
    ) -> str:
        """Build path string with template literals for path parameters"""
        # Extract path parameters
        parameters = operation.get("parameters", [])
        path_params = [p for p in parameters if isinstance(p, dict) and p.get("in") == "path"]

        if not path_params:
            return f'"{path}"'

        # Replace path parameters with template literals
        result = path
        for param in path_params:
            param_name = param.get("name", "")
            result = result.replace(f"{{{param_name}}}", f"${{{param_name}}}")

        return f"`{result}`"

    def _get_method_params(
        self,
        operation: Dict[str, Any],
        request_type: Optional[str]
    ) -> str:
        """Get method parameters string"""
        params = []

        # Add path parameters
        parameters = operation.get("parameters", [])
        path_params = [p for p in parameters if isinstance(p, dict) and p.get("in") == "path"]
        for param in path_params:
            param_name = param.get("name", "")
            param_type = self._get_parameter_type(param)
            params.append(f"{param_name}: {param_type}")

        # Add query parameters (as optional object)
        query_params = [p for p in parameters if isinstance(p, dict) and p.get("in") == "query"]
        if query_params:
            params.append("options?: any")

        # Add request body
        if request_type:
            params.append(f"input: {request_type}")

        return ", ".join(params) if params else ""

    def _get_parameter_type(self, param: Dict[str, Any]) -> str:
        """Get TypeScript type for a parameter"""
        schema = param.get("schema", {})
        param_type = schema.get("type", "string")

        type_map = {
            "string": "string",
            "number": "number",
            "integer": "number",
            "boolean": "boolean",
            "array": "unknown[]",
        }

        return type_map.get(param_type, "string")

    def _build_method_body(
        self,
        method: str,
        path: str,
        request_type: Optional[str]
    ) -> str:
        """Build method body"""
        if method == "get":
            if request_type:
                return f"""    const response = await this.http.get({path}, input);
    return response.data;"""
            else:
                return f"""    const response = await this.http.get({path});
    return response.data;"""
        elif method == "post":
            if request_type:
                return f"""    const response = await this.http.post({path}, input);
    return response.data;"""
            else:
                return f"""    const response = await this.http.post({path});
    return response.data;"""
        elif method == "put":
            if request_type:
                return f"""    const response = await this.http.put({path}, input);
    return response.data;"""
            else:
                return f"""    const response = await this.http.put({path});
    return response.data;"""
        elif method == "patch":
            if request_type:
                return f"""    const response = await this.http.patch({path}, input);
    return response.data;"""
            else:
                return f"""    const response = await this.http.patch({path});
    return response.data;"""
        elif method == "delete":
            return f"""    const response = await this.http.delete({path});
    return response.data;"""
        else:
            return f"""    const response = await this.http.request({path}, {{ method: "{method.upper()}" }});
    return response.data;"""
