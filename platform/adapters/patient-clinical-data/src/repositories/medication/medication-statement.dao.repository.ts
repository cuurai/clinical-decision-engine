/**
 * DAO adapter for MedicationStatementRepository
 *
 * Generated by Adapter Generator v1.0.0
 * Generator Version: 1.0.0
 * Domain: patient-clinical-data
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated. Any manual changes will be overwritten.
 */

import type { OrgId, PaginatedResult, PaginationParams } from "@cuur-cde/core/_shared";
import type { MedicationStatementRepository } from "@cuur-cde/core/patient-clinical-data";
import type {
  MedicationStatementInput,
  MedicationStatementUpdate,
  UpdateMedicationStatementRequest,
  MedicationStatement,
  Timestamps,
} from "@cuur-cde/core/patient-clinical-data";
import type { DaoClient } from "@cuur-cde/database";
import { NotFoundError, handleDatabaseError } from "@cuur-cde/core/_shared";

const DEFAULT_LIMIT = 50;

export class DaoMedicationStatementRepository implements MedicationStatementRepository {

  constructor(
    private readonly dao: DaoClient,
    private readonly tx: TransactionManager
  ) {
  }

  async list(
    orgId: OrgId,
    params?: PaginationParams
  ): Promise<PaginatedResult<MedicationStatement>> {
    try {
      const limit = params?.limit ?? DEFAULT_LIMIT;

      const records = await this.dao.medicationStatementInput.findMany({
        where: {
          orgId,
          deletedAt: null, // Soft delete filter - only return non-deleted records
        },
        orderBy: { createdAt: "desc" },
        take: limit,
        ...(params && "cursor" in params && params.cursor
          ? {
              skip: 1,
              cursor: { id: params.cursor },
            }
          : {}),
      });

      return {
        items: records.map((r: any) => this.toDomain(r)),
        nextCursor: records.length === limit ? records[records.length - 1]?.id : undefined,
        prevCursor: undefined,
      };
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async findById(orgId: OrgId, id: string): Promise<MedicationStatement | null> {
    try {
      const record = await this.dao.medicationStatementInput.findFirst({
        where: {
          orgId,
          id,
          deletedAt: null, // Soft delete filter - only return non-deleted records
        },
      });
      return record ? this.toDomain(record) : null;
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async get(orgId: OrgId, id: string): Promise<MedicationStatement | null> {
    const result = await this.findById(orgId, id);
    if (!result) {
      throw new NotFoundError("MedicationStatement", id);
    }
    return result;
  }
  async create(orgId: OrgId, data: MedicationStatement): Promise<MedicationStatement> {
    // Note: Repository interface expects MedicationStatement, but we only use input fields
    // Extract only the input fields to avoid including id, createdAt, updatedAt
    const inputData = data as unknown as MedicationStatementInput;
    try {
      const record = await this.dao.medicationStatementInput.create({
        data: {
          ...data,
          orgId, // Set orgId after spread to ensure it's always set correctly
        },
      });
      return this.toDomain(record);
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async update(
    orgId: OrgId,
    id: string,
    data: UpdateMedicationStatementRequest
  ): Promise<MedicationStatement> {
    try {
      const record = await this.dao.medicationStatementInput.update({
        where: { id, orgId },
        data: {
          ...data,
        },
      });
      return this.toDomain(record);
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async delete(orgId: OrgId, id: string): Promise<void> {
    try {
      // Soft delete: set deletedAt instead of hard delete
      await this.dao.medicationStatementInput.update({
        where: { id, orgId },
        data: {
          deletedAt: new Date(),
        },
      });
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async createMany(
    orgId: OrgId,
    items: Array<MedicationStatementInput>
  ): Promise<MedicationStatement[]> {
    try {
      // Use transaction with individual creates to get created records with IDs
      return await this.tx.run(async (tx) => {
        const results: MedicationStatement[] = [];
        for (const item of items) {
          const record = await tx.medicationStatementInput.create({
            data: {
              ...item,
              orgId,
            },
          });
          results.push(this.toDomain(record));
        }
        return results;
      });
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async updateMany(
    orgId: OrgId,
    updates: Array<{ id: string; data: MedicationStatementUpdate }>
  ): Promise<MedicationStatement[]> {
    try {
      // Use transaction for atomic batch updates
      return await this.tx.run(async (tx) => {
        const results: MedicationStatement[] = [];
        for (const { id, data } of updates) {
          const record = await tx.medicationStatementInput.update({
            where: { id, orgId },
            data,
          });
          results.push(this.toDomain(record));
        }
        return results;
      });
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async deleteMany(orgId: OrgId, ids: string[]): Promise<void> {
    try {
      // Soft delete: set deletedAt for multiple records
      await this.dao.medicationStatementInput.updateMany({
        where: {
          id: { in: ids },
          orgId,
        },
        data: {
          deletedAt: new Date(),
        },
      });
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  private toDomain(model: any): MedicationStatement {
    return {
      ...model,
      createdAt: model.createdAt instanceof Date ? model.createdAt : new Date(model.createdAt),
      updatedAt:
        model.updatedAt instanceof Date
          ? model.updatedAt
          : model.updatedAt
          ? new Date(model.updatedAt)
          : undefined,
    } as MedicationStatement;
  }
}
