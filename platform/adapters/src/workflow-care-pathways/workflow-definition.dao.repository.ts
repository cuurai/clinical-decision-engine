/**
 * DAO adapter for WorkflowDefinitionRepository
 *
 * Generated by Adapter Generator v1.0.0
 * Generator Version: 1.0.0
 * Domain: workflow-care-pathways
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated. Any manual changes will be overwritten.
 */

import type {
  OrgId,
  PaginatedResult,
  PaginationParams,
} from "@cuur/core";
import type {
  WorkflowDefinitionRepository,
} from "@cuur/core/workflow-care-pathways/repositories/index.js";
import type {
  Timestamps,
  WorkflowDefinitionInput,
  WorkflowDefinitionUpdate,
} from "@cuur/core/workflow-care-pathways/types/index.js";
import type { DaoClient } from "../shared/dao-client.js";
import { NotFoundError, TransactionManager, handleDatabaseError } from "../shared/index.js";

const DEFAULT_LIMIT = 50;

export class DaoWorkflowDefinitionRepository implements WorkflowDefinitionRepository {
  private transactionManager: TransactionManager;

  constructor(private readonly dao: DaoClient) {
    this.transactionManager = new TransactionManager(dao);
  }

  async list(
    orgId: OrgId,
    params?: PaginationParams
  ): Promise<PaginatedResult<Timestamps>> {
    try {
      const limit = params?.limit ?? DEFAULT_LIMIT;

      const records = await this.dao.workflowDefinition.findMany({
        where: {
          orgId,
          deletedAt: null, // Soft delete filter - only return non-deleted records
        },
        orderBy: { createdAt: "desc" },
        take: limit,
        ...(params?.cursor ? {
          skip: 1,
          cursor: { id: params.cursor },
        } : {}),
      });

      return {
        items: records.map((r) => this.toDomain(r)),
        nextCursor: records.length === limit
          ? records[records.length - 1]?.id
          : undefined,
        prevCursor: undefined,
      };
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async findById(orgId: OrgId, id: string): Promise<Timestamps | null> {
    try {
      const record = await this.dao.workflowDefinition.findFirst({
        where: {
          orgId,
          id,
          deletedAt: null, // Soft delete filter - only return non-deleted records
        },
      });
      return record ? this.toDomain(record) : null;
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async get(orgId: OrgId, id: string): Promise<Timestamps | null> {
    const result = await this.findById(orgId, id);
    if (!result) {
      throw new NotFoundError("Timestamps", id);
    }
    return result;
  }
  async create(orgId: OrgId, data: WorkflowDefinitionInput, createdBy?: string): Promise<Timestamps> {
    try {
      const record = await this.dao.workflowDefinition.create({
        data: {
          ...data,
          orgId, // Set orgId after spread to ensure it's always set correctly
          createdBy: createdBy ?? null, // Audit trail
        },
      });
      return this.toDomain(record);
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async update(orgId: OrgId, id: string, data: WorkflowDefinitionUpdate, updatedBy?: string): Promise<Timestamps> {
    try {
      const record = await this.dao.workflowDefinition.update({
        where: { id },
        data: {
          ...data,
          updatedBy: updatedBy ?? null, // Audit trail
        },
      });
      return this.toDomain(record);
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async delete(orgId: OrgId, id: string, deletedBy?: string): Promise<void> {
    try {
      // Soft delete: set deletedAt instead of hard delete
      await this.dao.workflowDefinition.update({
        where: { id },
        data: {
          deletedAt: new Date(),
          deletedBy: deletedBy ?? null,
        },
      });
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async createMany(orgId: OrgId, items: Array<WorkflowDefinitionInput>): Promise<Timestamps[]> {
    try {
      // Use createMany for better performance
      await this.dao.workflowDefinition.createMany({
        data: items.map(item => ({
          ...item,
          orgId,
        })),
        skipDuplicates: true,
      });

      // Fetch created records
      const ids = items.map(item => item.id).filter(Boolean) as string[];
      if (ids.length === 0) {
        return [];
      }

      const records = await this.dao.workflowDefinition.findMany({
        where: { id: { in: ids }, orgId },
      });

      return records.map((r) => this.toDomain(r));
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async updateMany(orgId: OrgId, updates: Array<{ id: string; data: WorkflowDefinitionUpdate }>): Promise<Timestamps[]> {
    try {
      // Use transaction for atomic batch updates
      return await this.transactionManager.execute(orgId, async (tx) => {
        const results: Timestamps[] = [];
        for (const { id, data } of updates) {
          const record = await tx.workflowDefinition.update({
            where: { id },
            data,
          });
          results.push(this.toDomain(record));
        }
        return results;
      });
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  async deleteMany(orgId: OrgId, ids: string[], deletedBy?: string): Promise<void> {
    try {
      // Soft delete: set deletedAt for multiple records
      await this.dao.workflowDefinition.updateMany({
        where: {
          id: { in: ids },
          orgId,
        },
        data: {
          deletedAt: new Date(),
          deletedBy: deletedBy ?? null,
        },
      });
    } catch (error) {
      handleDatabaseError(error);
      throw error;
    }
  }
  private toDomain(model: any): Timestamps {
    return {
      ...model,
      createdAt: model.createdAt instanceof Date
        ? model.createdAt
        : new Date(model.createdAt),
      updatedAt: model.updatedAt instanceof Date
        ? model.updatedAt
        : model.updatedAt ? new Date(model.updatedAt) : undefined,
    } as Timestamps;
  }
}
