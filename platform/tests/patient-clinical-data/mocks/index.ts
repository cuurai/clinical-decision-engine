/**
 * Mock Repositories for Testing
 *
 * Generated by Test Generator v1.0.0
 * Generator Version: 1.0.0
 * Domain: patient-clinical-data
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated. Any manual changes will be overwritten.
 */

import type {
  PatientProcedureRepository,
  ConditionNoteRepository,
  MedicationStatementRepository,
  DocumentRepository,
  DiagnosticReportImagingStudyRepository,
  PatientLabRepository,
  ImagingStudySeriesRepository,
  EncounterConditionRepository,
  ImmunizationRepository,
  PatientObservationRepository,
  EncounterNoteRepository,
  PatientImmunizationRepository,
  PatientVitalRepository,
  DiagnosticReportRepository,
  ProcedureRepository,
  MedicationOrderRepository,
  NoteRepository,
  PatientAllergyRepository,
  PatientRepository,
  PatientCareTeamRepository,
  PatientMedicationRepository,
  EncounterProcedureRepository,
  MedicationAdministrationRepository,
  PatientDocumentRepository,
  PatientConditionRepository,
  ObservationRepository,
  AllergyRepository,
  PatientEncounterRepository,
  EncounterRepository,
  PatientSummaryRepository,
  ConditionRepository,
  EncounterDiagnosticReportRepository,
  PatientDiagnosticReportRepository,
  EncounterObservationRepository,
  DiagnosticReportObservationRepository,
  CareTeamRepository,
  ImagingStudyRepository,
  PatientNoteRepository,
} from "@cuur-cde/core/patient-clinical-data/repositories/index.js";
import type {
  Allergy,
  CareTeam,
  Condition,
  ConditionNote,
  DiagnosticReport,
  DiagnosticReportImagingStudy,
  DiagnosticReportObservation,
  Document,
  Encounter,
  EncounterCondition,
  EncounterDiagnosticReport,
  EncounterNote,
  EncounterObservation,
  EncounterProcedure,
  ImagingStudy,
  ImagingStudySeries,
  Immunization,
  MedicationAdministration,
  MedicationOrder,
  MedicationStatement,
  Note,
  Observation,
  Patient,
  PatientAllergy,
  PatientCareTeam,
  PatientCondition,
  PatientDiagnosticReport,
  PatientDocument,
  PatientEncounter,
  PatientImmunization,
  PatientLab,
  PatientMedication,
  PatientNote,
  PatientObservation,
  PatientProcedure,
  PatientSummary,
  PatientVital,
  Procedure,
  AllergyInput,
  CareTeamInput,
  ClinicalNoteInput,
  ConditionInput,
  DiagnosticReportInput,
  DocumentReferenceInput,
  EncounterInput,
  ImagingStudyInput,
  ImmunizationInput,
  MedicationOrderInput,
  MedicationStatementInput,
  ObservationInput,
  PatientInput,
  ProcedureInput,
  AllergyUpdate,
  CareTeamUpdate,
  ClinicalNoteUpdate,
  ConditionUpdate,
  DiagnosticReportUpdate,
  DocumentReferenceUpdate,
  EncounterUpdate,
  ImagingStudyUpdate,
  ImmunizationUpdate,
  MedicationOrderUpdate,
  MedicationStatementUpdate,
  ObservationUpdate,
  PatientUpdate,
  ProcedureUpdate,
} from "@cuur-cde/core/patient-clinical-data/types/index.js";
import type {
  ListAllergiesParams,
  ListCareTeamsParams,
  ListConditionsParams,
  ListDiagnosticReportsParams,
  ListDocumentsParams,
  ListEncountersParams,
  ListImagingStudiesParams,
  ListImmunizationsParams,
  ListMedicationOrdersParams,
  ListMedicationStatementsParams,
  ListNotesParams,
  ListObservationsParams,
  ListPatientObservationsParams,
  ListPatientsParams,
  ListProceduresParams,
  PaginationParams,
  PaginatedResult,
} from "@cuur-cde/core/shared/helpers/index.js";
import { pcTransactionId } from "@cuur-cde/core/shared/helpers/id-generator.js";


/**
 * Mock PatientProcedureRepository for testing
 */export class MockPatientProcedureRepository implements PatientProcedureRepository {
  private patientProcedures: PatientProcedure[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientProcedures = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientProcedure>> {
    let items = this.patientProcedures.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientProcedure | null> {
    return this.patientProcedures.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientProcedure | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ConditionNoteRepository for testing
 */export class MockConditionNoteRepository implements ConditionNoteRepository {
  private conditionNotes: ConditionNote[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.conditionNotes = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ConditionNote>> {
    let items = this.conditionNotes.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ConditionNote | null> {
    return this.conditionNotes.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ConditionNote | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock MedicationStatementRepository for testing
 */export class MockMedicationStatementRepository implements MedicationStatementRepository {
  private medicationStatements: MedicationStatement[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.medicationStatements = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListMedicationStatementsParams
  ): Promise<PaginatedResult<MedicationStatement>> {
    let items = this.medicationStatements.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<MedicationStatement | null> {
    return this.medicationStatements.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<MedicationStatement | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: MedicationStatementInput): Promise<MedicationStatement> {
    const medicationStatement: MedicationStatement = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as MedicationStatement;
    this.medicationStatements.push(medicationStatement);
    return medicationStatement;
  }

  async update(orgId: string, id: string, data: MedicationStatementUpdate): Promise<MedicationStatement> {
    const medicationStatement = await this.findById(orgId, id);
    if (!medicationStatement) {
      throw new Error(`MedicationStatement ${id} not found`);
    }
    Object.assign(medicationStatement, data, { updatedAt: new Date() });
    return medicationStatement;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.medicationStatements.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`MedicationStatement ${id} not found`);
    }
    this.medicationStatements.splice(index, 1);
  }
}

/**
 * Mock DocumentRepository for testing
 */export class MockDocumentRepository implements DocumentRepository {
  private documents: Document[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.documents = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListDocumentsParams
  ): Promise<PaginatedResult<Document>> {
    let items = this.documents.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Document | null> {
    return this.documents.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Document | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: DocumentReferenceInput): Promise<Document> {
    const document: Document = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Document;
    this.documents.push(document);
    return document;
  }

  async update(orgId: string, id: string, data: DocumentReferenceUpdate): Promise<Document> {
    const document = await this.findById(orgId, id);
    if (!document) {
      throw new Error(`Document ${id} not found`);
    }
    Object.assign(document, data, { updatedAt: new Date() });
    return document;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.documents.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Document ${id} not found`);
    }
    this.documents.splice(index, 1);
  }
}

/**
 * Mock DiagnosticReportImagingStudyRepository for testing
 */export class MockDiagnosticReportImagingStudyRepository implements DiagnosticReportImagingStudyRepository {
  private diagnosticReportImagingStudys: DiagnosticReportImagingStudy[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.diagnosticReportImagingStudys = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DiagnosticReportImagingStudy>> {
    let items = this.diagnosticReportImagingStudys.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DiagnosticReportImagingStudy | null> {
    return this.diagnosticReportImagingStudys.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DiagnosticReportImagingStudy | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock PatientLabRepository for testing
 */export class MockPatientLabRepository implements PatientLabRepository {
  private patientLabs: PatientLab[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientLabs = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientLab>> {
    let items = this.patientLabs.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientLab | null> {
    return this.patientLabs.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientLab | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ImagingStudySeriesRepository for testing
 */export class MockImagingStudySeriesRepository implements ImagingStudySeriesRepository {
  private imagingStudySeriess: ImagingStudySeries[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.imagingStudySeriess = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ImagingStudySeries>> {
    let items = this.imagingStudySeriess.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ImagingStudySeries | null> {
    return this.imagingStudySeriess.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ImagingStudySeries | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EncounterConditionRepository for testing
 */export class MockEncounterConditionRepository implements EncounterConditionRepository {
  private encounterConditions: EncounterCondition[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.encounterConditions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<EncounterCondition>> {
    let items = this.encounterConditions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EncounterCondition | null> {
    return this.encounterConditions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EncounterCondition | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ImmunizationRepository for testing
 */export class MockImmunizationRepository implements ImmunizationRepository {
  private immunizations: Immunization[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.immunizations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListImmunizationsParams
  ): Promise<PaginatedResult<Immunization>> {
    let items = this.immunizations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Immunization | null> {
    return this.immunizations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Immunization | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ImmunizationInput): Promise<Immunization> {
    const immunization: Immunization = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Immunization;
    this.immunizations.push(immunization);
    return immunization;
  }

  async update(orgId: string, id: string, data: ImmunizationUpdate): Promise<Immunization> {
    const immunization = await this.findById(orgId, id);
    if (!immunization) {
      throw new Error(`Immunization ${id} not found`);
    }
    Object.assign(immunization, data, { updatedAt: new Date() });
    return immunization;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.immunizations.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Immunization ${id} not found`);
    }
    this.immunizations.splice(index, 1);
  }
}

/**
 * Mock PatientObservationRepository for testing
 */export class MockPatientObservationRepository implements PatientObservationRepository {
  private patientObservations: PatientObservation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientObservations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListPatientObservationsParams
  ): Promise<PaginatedResult<PatientObservation>> {
    let items = this.patientObservations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientObservation | null> {
    return this.patientObservations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientObservation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EncounterNoteRepository for testing
 */export class MockEncounterNoteRepository implements EncounterNoteRepository {
  private encounterNotes: EncounterNote[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.encounterNotes = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<EncounterNote>> {
    let items = this.encounterNotes.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EncounterNote | null> {
    return this.encounterNotes.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EncounterNote | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock PatientImmunizationRepository for testing
 */export class MockPatientImmunizationRepository implements PatientImmunizationRepository {
  private patientImmunizations: PatientImmunization[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientImmunizations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientImmunization>> {
    let items = this.patientImmunizations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientImmunization | null> {
    return this.patientImmunizations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientImmunization | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock PatientVitalRepository for testing
 */export class MockPatientVitalRepository implements PatientVitalRepository {
  private patientVitals: PatientVital[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientVitals = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientVital>> {
    let items = this.patientVitals.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientVital | null> {
    return this.patientVitals.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientVital | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DiagnosticReportRepository for testing
 */export class MockDiagnosticReportRepository implements DiagnosticReportRepository {
  private diagnosticReports: DiagnosticReport[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.diagnosticReports = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListDiagnosticReportsParams
  ): Promise<PaginatedResult<DiagnosticReport>> {
    let items = this.diagnosticReports.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DiagnosticReport | null> {
    return this.diagnosticReports.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DiagnosticReport | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: DiagnosticReportInput): Promise<DiagnosticReport> {
    const diagnosticReport: DiagnosticReport = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as DiagnosticReport;
    this.diagnosticReports.push(diagnosticReport);
    return diagnosticReport;
  }

  async update(orgId: string, id: string, data: DiagnosticReportUpdate): Promise<DiagnosticReport> {
    const diagnosticReport = await this.findById(orgId, id);
    if (!diagnosticReport) {
      throw new Error(`DiagnosticReport ${id} not found`);
    }
    Object.assign(diagnosticReport, data, { updatedAt: new Date() });
    return diagnosticReport;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.diagnosticReports.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`DiagnosticReport ${id} not found`);
    }
    this.diagnosticReports.splice(index, 1);
  }
}

/**
 * Mock ProcedureRepository for testing
 */export class MockProcedureRepository implements ProcedureRepository {
  private procedures: Procedure[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.procedures = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListProceduresParams
  ): Promise<PaginatedResult<Procedure>> {
    let items = this.procedures.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Procedure | null> {
    return this.procedures.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Procedure | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ProcedureInput): Promise<Procedure> {
    const procedure: Procedure = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Procedure;
    this.procedures.push(procedure);
    return procedure;
  }

  async update(orgId: string, id: string, data: ProcedureUpdate): Promise<Procedure> {
    const procedure = await this.findById(orgId, id);
    if (!procedure) {
      throw new Error(`Procedure ${id} not found`);
    }
    Object.assign(procedure, data, { updatedAt: new Date() });
    return procedure;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.procedures.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Procedure ${id} not found`);
    }
    this.procedures.splice(index, 1);
  }
}

/**
 * Mock MedicationOrderRepository for testing
 */export class MockMedicationOrderRepository implements MedicationOrderRepository {
  private medicationOrders: MedicationOrder[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.medicationOrders = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListMedicationOrdersParams
  ): Promise<PaginatedResult<MedicationOrder>> {
    let items = this.medicationOrders.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<MedicationOrder | null> {
    return this.medicationOrders.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<MedicationOrder | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: MedicationOrderInput): Promise<MedicationOrder> {
    const medicationOrder: MedicationOrder = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as MedicationOrder;
    this.medicationOrders.push(medicationOrder);
    return medicationOrder;
  }

  async update(orgId: string, id: string, data: MedicationOrderUpdate): Promise<MedicationOrder> {
    const medicationOrder = await this.findById(orgId, id);
    if (!medicationOrder) {
      throw new Error(`MedicationOrder ${id} not found`);
    }
    Object.assign(medicationOrder, data, { updatedAt: new Date() });
    return medicationOrder;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.medicationOrders.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`MedicationOrder ${id} not found`);
    }
    this.medicationOrders.splice(index, 1);
  }
}

/**
 * Mock NoteRepository for testing
 */export class MockNoteRepository implements NoteRepository {
  private notes: Note[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.notes = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListNotesParams
  ): Promise<PaginatedResult<Note>> {
    let items = this.notes.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Note | null> {
    return this.notes.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Note | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ClinicalNoteInput): Promise<Note> {
    const note: Note = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Note;
    this.notes.push(note);
    return note;
  }

  async update(orgId: string, id: string, data: ClinicalNoteUpdate): Promise<Note> {
    const note = await this.findById(orgId, id);
    if (!note) {
      throw new Error(`Note ${id} not found`);
    }
    Object.assign(note, data, { updatedAt: new Date() });
    return note;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.notes.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Note ${id} not found`);
    }
    this.notes.splice(index, 1);
  }
}

/**
 * Mock PatientAllergyRepository for testing
 */export class MockPatientAllergyRepository implements PatientAllergyRepository {
  private patientAllergys: PatientAllergy[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientAllergys = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientAllergy>> {
    let items = this.patientAllergys.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientAllergy | null> {
    return this.patientAllergys.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientAllergy | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock PatientRepository for testing
 */export class MockPatientRepository implements PatientRepository {
  private patients: Patient[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patients = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListPatientsParams
  ): Promise<PaginatedResult<Patient>> {
    let items = this.patients.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Patient | null> {
    return this.patients.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Patient | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: PatientInput): Promise<Patient> {
    const patient: Patient = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Patient;
    this.patients.push(patient);
    return patient;
  }

  async update(orgId: string, id: string, data: PatientUpdate): Promise<Patient> {
    const patient = await this.findById(orgId, id);
    if (!patient) {
      throw new Error(`Patient ${id} not found`);
    }
    Object.assign(patient, data, { updatedAt: new Date() });
    return patient;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.patients.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Patient ${id} not found`);
    }
    this.patients.splice(index, 1);
  }
}

/**
 * Mock PatientCareTeamRepository for testing
 */export class MockPatientCareTeamRepository implements PatientCareTeamRepository {
  private patientCareTeams: PatientCareTeam[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientCareTeams = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientCareTeam>> {
    let items = this.patientCareTeams.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientCareTeam | null> {
    return this.patientCareTeams.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientCareTeam | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock PatientMedicationRepository for testing
 */export class MockPatientMedicationRepository implements PatientMedicationRepository {
  private patientMedications: PatientMedication[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientMedications = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientMedication>> {
    let items = this.patientMedications.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientMedication | null> {
    return this.patientMedications.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientMedication | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EncounterProcedureRepository for testing
 */export class MockEncounterProcedureRepository implements EncounterProcedureRepository {
  private encounterProcedures: EncounterProcedure[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.encounterProcedures = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<EncounterProcedure>> {
    let items = this.encounterProcedures.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EncounterProcedure | null> {
    return this.encounterProcedures.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EncounterProcedure | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock MedicationAdministrationRepository for testing
 */export class MockMedicationAdministrationRepository implements MedicationAdministrationRepository {
  private medicationAdministrations: MedicationAdministration[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.medicationAdministrations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<MedicationAdministration>> {
    let items = this.medicationAdministrations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<MedicationAdministration | null> {
    return this.medicationAdministrations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<MedicationAdministration | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock PatientDocumentRepository for testing
 */export class MockPatientDocumentRepository implements PatientDocumentRepository {
  private patientDocuments: PatientDocument[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientDocuments = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientDocument>> {
    let items = this.patientDocuments.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientDocument | null> {
    return this.patientDocuments.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientDocument | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock PatientConditionRepository for testing
 */export class MockPatientConditionRepository implements PatientConditionRepository {
  private patientConditions: PatientCondition[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientConditions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientCondition>> {
    let items = this.patientConditions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientCondition | null> {
    return this.patientConditions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientCondition | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ObservationRepository for testing
 */export class MockObservationRepository implements ObservationRepository {
  private observations: Observation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.observations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListObservationsParams
  ): Promise<PaginatedResult<Observation>> {
    let items = this.observations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Observation | null> {
    return this.observations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Observation | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ObservationInput): Promise<Observation> {
    const observation: Observation = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Observation;
    this.observations.push(observation);
    return observation;
  }

  async update(orgId: string, id: string, data: ObservationUpdate): Promise<Observation> {
    const observation = await this.findById(orgId, id);
    if (!observation) {
      throw new Error(`Observation ${id} not found`);
    }
    Object.assign(observation, data, { updatedAt: new Date() });
    return observation;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.observations.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Observation ${id} not found`);
    }
    this.observations.splice(index, 1);
  }
}

/**
 * Mock AllergyRepository for testing
 */export class MockAllergyRepository implements AllergyRepository {
  private allergys: Allergy[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.allergys = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListAllergiesParams
  ): Promise<PaginatedResult<Allergy>> {
    let items = this.allergys.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Allergy | null> {
    return this.allergys.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Allergy | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: AllergyInput): Promise<Allergy> {
    const allergy: Allergy = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Allergy;
    this.allergys.push(allergy);
    return allergy;
  }

  async update(orgId: string, id: string, data: AllergyUpdate): Promise<Allergy> {
    const allergy = await this.findById(orgId, id);
    if (!allergy) {
      throw new Error(`Allergy ${id} not found`);
    }
    Object.assign(allergy, data, { updatedAt: new Date() });
    return allergy;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.allergys.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Allergy ${id} not found`);
    }
    this.allergys.splice(index, 1);
  }
}

/**
 * Mock PatientEncounterRepository for testing
 */export class MockPatientEncounterRepository implements PatientEncounterRepository {
  private patientEncounters: PatientEncounter[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientEncounters = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientEncounter>> {
    let items = this.patientEncounters.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientEncounter | null> {
    return this.patientEncounters.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientEncounter | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EncounterRepository for testing
 */export class MockEncounterRepository implements EncounterRepository {
  private encounters: Encounter[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.encounters = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListEncountersParams
  ): Promise<PaginatedResult<Encounter>> {
    let items = this.encounters.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Encounter | null> {
    return this.encounters.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Encounter | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: EncounterInput): Promise<Encounter> {
    const encounter: Encounter = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Encounter;
    this.encounters.push(encounter);
    return encounter;
  }

  async update(orgId: string, id: string, data: EncounterUpdate): Promise<Encounter> {
    const encounter = await this.findById(orgId, id);
    if (!encounter) {
      throw new Error(`Encounter ${id} not found`);
    }
    Object.assign(encounter, data, { updatedAt: new Date() });
    return encounter;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.encounters.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Encounter ${id} not found`);
    }
    this.encounters.splice(index, 1);
  }
}

/**
 * Mock PatientSummaryRepository for testing
 */export class MockPatientSummaryRepository implements PatientSummaryRepository {
  private patientSummarys: PatientSummary[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientSummarys = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientSummary>> {
    let items = this.patientSummarys.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientSummary | null> {
    return this.patientSummarys.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientSummary | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ConditionRepository for testing
 */export class MockConditionRepository implements ConditionRepository {
  private conditions: Condition[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.conditions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListConditionsParams
  ): Promise<PaginatedResult<Condition>> {
    let items = this.conditions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Condition | null> {
    return this.conditions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Condition | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ConditionInput): Promise<Condition> {
    const condition: Condition = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Condition;
    this.conditions.push(condition);
    return condition;
  }

  async update(orgId: string, id: string, data: ConditionUpdate): Promise<Condition> {
    const condition = await this.findById(orgId, id);
    if (!condition) {
      throw new Error(`Condition ${id} not found`);
    }
    Object.assign(condition, data, { updatedAt: new Date() });
    return condition;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.conditions.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Condition ${id} not found`);
    }
    this.conditions.splice(index, 1);
  }
}

/**
 * Mock EncounterDiagnosticReportRepository for testing
 */export class MockEncounterDiagnosticReportRepository implements EncounterDiagnosticReportRepository {
  private encounterDiagnosticReports: EncounterDiagnosticReport[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.encounterDiagnosticReports = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<EncounterDiagnosticReport>> {
    let items = this.encounterDiagnosticReports.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EncounterDiagnosticReport | null> {
    return this.encounterDiagnosticReports.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EncounterDiagnosticReport | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock PatientDiagnosticReportRepository for testing
 */export class MockPatientDiagnosticReportRepository implements PatientDiagnosticReportRepository {
  private patientDiagnosticReports: PatientDiagnosticReport[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientDiagnosticReports = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientDiagnosticReport>> {
    let items = this.patientDiagnosticReports.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientDiagnosticReport | null> {
    return this.patientDiagnosticReports.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientDiagnosticReport | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EncounterObservationRepository for testing
 */export class MockEncounterObservationRepository implements EncounterObservationRepository {
  private encounterObservations: EncounterObservation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.encounterObservations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<EncounterObservation>> {
    let items = this.encounterObservations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EncounterObservation | null> {
    return this.encounterObservations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EncounterObservation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DiagnosticReportObservationRepository for testing
 */export class MockDiagnosticReportObservationRepository implements DiagnosticReportObservationRepository {
  private diagnosticReportObservations: DiagnosticReportObservation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.diagnosticReportObservations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DiagnosticReportObservation>> {
    let items = this.diagnosticReportObservations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DiagnosticReportObservation | null> {
    return this.diagnosticReportObservations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DiagnosticReportObservation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock CareTeamRepository for testing
 */export class MockCareTeamRepository implements CareTeamRepository {
  private careTeams: CareTeam[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.careTeams = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListCareTeamsParams
  ): Promise<PaginatedResult<CareTeam>> {
    let items = this.careTeams.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CareTeam | null> {
    return this.careTeams.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CareTeam | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CareTeamInput): Promise<CareTeam> {
    const careTeam: CareTeam = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as CareTeam;
    this.careTeams.push(careTeam);
    return careTeam;
  }

  async update(orgId: string, id: string, data: CareTeamUpdate): Promise<CareTeam> {
    const careTeam = await this.findById(orgId, id);
    if (!careTeam) {
      throw new Error(`CareTeam ${id} not found`);
    }
    Object.assign(careTeam, data, { updatedAt: new Date() });
    return careTeam;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.careTeams.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`CareTeam ${id} not found`);
    }
    this.careTeams.splice(index, 1);
  }
}

/**
 * Mock ImagingStudyRepository for testing
 */export class MockImagingStudyRepository implements ImagingStudyRepository {
  private imagingStudys: ImagingStudy[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.imagingStudys = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListImagingStudiesParams
  ): Promise<PaginatedResult<ImagingStudy>> {
    let items = this.imagingStudys.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ImagingStudy | null> {
    return this.imagingStudys.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ImagingStudy | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ImagingStudyInput): Promise<ImagingStudy> {
    const imagingStudy: ImagingStudy = {
      ...data,
      id: pcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ImagingStudy;
    this.imagingStudys.push(imagingStudy);
    return imagingStudy;
  }

  async update(orgId: string, id: string, data: ImagingStudyUpdate): Promise<ImagingStudy> {
    const imagingStudy = await this.findById(orgId, id);
    if (!imagingStudy) {
      throw new Error(`ImagingStudy ${id} not found`);
    }
    Object.assign(imagingStudy, data, { updatedAt: new Date() });
    return imagingStudy;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.imagingStudys.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ImagingStudy ${id} not found`);
    }
    this.imagingStudys.splice(index, 1);
  }
}

/**
 * Mock PatientNoteRepository for testing
 */export class MockPatientNoteRepository implements PatientNoteRepository {
  private patientNotes: PatientNote[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.patientNotes = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<PatientNote>> {
    let items = this.patientNotes.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<PatientNote | null> {
    return this.patientNotes.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<PatientNote | null> {
    return this.findById(orgId, id);
  }
}

