/**
 * Mock Repositories for Testing
 *
 * Generated by Test Generator v1.0.0
 * Generator Version: 1.0.0
 * Domain: integration-interoperability
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated. Any manual changes will be overwritten.
 */

import type {
  FhirmappingProfileRepository,
  IntegrationJobRepository,
  HlMessageMappingResultRepository,
  HlMappingProfileRepository,
  ConnectionRepository,
  ExternalSystemIntegrationJobRepository,
  EventSubscriptionRepository,
  FhirbundleResourceRepository,
  DataImportBatchRecordRepository,
  IntegrationJobRunRepository,
  InterfaceHealthCheckRepository,
  FhirbundleRepository,
  DataExportBatchFileRepository,
  ConnectionIntegrationJobRepository,
  ApiclientCredentialRepository,
  ConnectionHealthCheckRepository,
  ExternalSystemRepository,
  ApiclientUsageMetricRepository,
  DataImportBatchRepository,
  HlMappingProfileRuleRepository,
  IntegrationRunRepository,
  ExternalSystemConnectionRepository,
  ApiclientRepository,
  ExternalSystemEndpointRepository,
  DataExportBatchErrorRepository,
  DataExportBatchRepository,
  ApicredentialRepository,
  HlMessageSegmentRepository,
  IntegrationRunErrorRepository,
  FhirmappingProfileRuleRepository,
  EventDeliveryRepository,
  HlMessageRepository,
  InterfaceErrorRepository,
  IntegrationRunLogRepository,
  DataImportBatchErrorRepository,
  EventSubscriptionDeliveryRepository,
} from "@cuur-cde/core/integration-interoperability/repositories/index.js";
import type {
  Apiclient,
  ApiclientCredential,
  ApiclientUsageMetric,
  Apicredential,
  Connection,
  ConnectionHealthCheck,
  ConnectionIntegrationJob,
  DataExportBatch,
  DataExportBatchError,
  DataExportBatchFile,
  DataImportBatch,
  DataImportBatchError,
  DataImportBatchRecord,
  EventDelivery,
  EventSubscription,
  EventSubscriptionDelivery,
  ExternalSystem,
  ExternalSystemConnection,
  ExternalSystemEndpoint,
  ExternalSystemIntegrationJob,
  Fhirbundle,
  FhirbundleResource,
  FhirmappingProfile,
  FhirmappingProfileRule,
  HlMappingProfile,
  HlMappingProfileRule,
  HlMessage,
  HlMessageMappingResult,
  HlMessageSegment,
  IntegrationJob,
  IntegrationJobRun,
  IntegrationRun,
  IntegrationRunError,
  IntegrationRunLog,
  InterfaceError,
  InterfaceHealthCheck,
  APIClientInput,
  APICredentialInput,
  ConnectionInput,
  DataExportBatchInput,
  DataImportBatchInput,
  EventSubscriptionInput,
  ExternalSystemInput,
  FHIRMappingProfileInput,
  HL7MappingProfileInput,
  IntegrationJobInput,
  APIClientUpdate,
  APICredentialUpdate,
  ConnectionUpdate,
  DataExportBatchUpdate,
  DataImportBatchUpdate,
  EventSubscriptionUpdate,
  ExternalSystemUpdate,
  FHIRMappingProfileUpdate,
  HL7MappingProfileUpdate,
  IntegrationJobUpdate,
} from "@cuur-cde/core/integration-interoperability/types/index.js";
import type {
  EventDeliveryUpdate,
  InterfaceErrorUpdate,
  ListAPIClientsParams,
  ListAPICredentialsParams,
  ListConnectionsParams,
  ListDataExportBatchesParams,
  ListDataImportBatchesParams,
  ListEventSubscriptionsParams,
  ListExternalSystemsParams,
  ListFHIRMappingProfilesParams,
  ListHLMappingProfilesParams,
  ListIntegrationJobsParams,
  PaginationParams,
  PaginatedResult,
} from "@cuur-cde/core/shared/helpers/index.js";
import { iiTransactionId } from "@cuur-cde/core/shared/helpers/id-generator.js";


/**
 * Mock FhirmappingProfileRepository for testing
 */export class MockFhirmappingProfileRepository implements FhirmappingProfileRepository {
  private fhirmappingProfiles: FhirmappingProfile[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.fhirmappingProfiles = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListFHIRMappingProfilesParams
  ): Promise<PaginatedResult<FhirmappingProfile>> {
    let items = this.fhirmappingProfiles.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<FhirmappingProfile | null> {
    return this.fhirmappingProfiles.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<FhirmappingProfile | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: FHIRMappingProfileInput): Promise<FhirmappingProfile> {
    const fhirmappingProfile: FhirmappingProfile = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as FhirmappingProfile;
    this.fhirmappingProfiles.push(fhirmappingProfile);
    return fhirmappingProfile;
  }

  async update(orgId: string, id: string, data: FHIRMappingProfileUpdate): Promise<FhirmappingProfile> {
    const fhirmappingProfile = await this.findById(orgId, id);
    if (!fhirmappingProfile) {
      throw new Error(`FhirmappingProfile ${id} not found`);
    }
    Object.assign(fhirmappingProfile, data, { updatedAt: new Date() });
    return fhirmappingProfile;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.fhirmappingProfiles.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`FhirmappingProfile ${id} not found`);
    }
    this.fhirmappingProfiles.splice(index, 1);
  }
}

/**
 * Mock IntegrationJobRepository for testing
 */export class MockIntegrationJobRepository implements IntegrationJobRepository {
  private integrationJobs: IntegrationJob[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.integrationJobs = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListIntegrationJobsParams
  ): Promise<PaginatedResult<IntegrationJob>> {
    let items = this.integrationJobs.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<IntegrationJob | null> {
    return this.integrationJobs.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<IntegrationJob | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: IntegrationJobInput): Promise<IntegrationJob> {
    const integrationJob: IntegrationJob = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as IntegrationJob;
    this.integrationJobs.push(integrationJob);
    return integrationJob;
  }

  async update(orgId: string, id: string, data: IntegrationJobUpdate): Promise<IntegrationJob> {
    const integrationJob = await this.findById(orgId, id);
    if (!integrationJob) {
      throw new Error(`IntegrationJob ${id} not found`);
    }
    Object.assign(integrationJob, data, { updatedAt: new Date() });
    return integrationJob;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.integrationJobs.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`IntegrationJob ${id} not found`);
    }
    this.integrationJobs.splice(index, 1);
  }
}

/**
 * Mock HlMessageMappingResultRepository for testing
 */export class MockHlMessageMappingResultRepository implements HlMessageMappingResultRepository {
  private hlMessageMappingResults: HlMessageMappingResult[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.hlMessageMappingResults = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<HlMessageMappingResult>> {
    let items = this.hlMessageMappingResults.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<HlMessageMappingResult | null> {
    return this.hlMessageMappingResults.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<HlMessageMappingResult | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock HlMappingProfileRepository for testing
 */export class MockHlMappingProfileRepository implements HlMappingProfileRepository {
  private hlMappingProfiles: HlMappingProfile[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.hlMappingProfiles = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListHLMappingProfilesParams
  ): Promise<PaginatedResult<HlMappingProfile>> {
    let items = this.hlMappingProfiles.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<HlMappingProfile | null> {
    return this.hlMappingProfiles.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<HlMappingProfile | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: HL7MappingProfileInput): Promise<HlMappingProfile> {
    const hlMappingProfile: HlMappingProfile = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as HlMappingProfile;
    this.hlMappingProfiles.push(hlMappingProfile);
    return hlMappingProfile;
  }

  async update(orgId: string, id: string, data: HL7MappingProfileUpdate): Promise<HlMappingProfile> {
    const hlMappingProfile = await this.findById(orgId, id);
    if (!hlMappingProfile) {
      throw new Error(`HlMappingProfile ${id} not found`);
    }
    Object.assign(hlMappingProfile, data, { updatedAt: new Date() });
    return hlMappingProfile;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.hlMappingProfiles.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`HlMappingProfile ${id} not found`);
    }
    this.hlMappingProfiles.splice(index, 1);
  }
}

/**
 * Mock ConnectionRepository for testing
 */export class MockConnectionRepository implements ConnectionRepository {
  private connections: Connection[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.connections = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListConnectionsParams
  ): Promise<PaginatedResult<Connection>> {
    let items = this.connections.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Connection | null> {
    return this.connections.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Connection | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ConnectionInput): Promise<Connection> {
    const connection: Connection = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Connection;
    this.connections.push(connection);
    return connection;
  }

  async update(orgId: string, id: string, data: ConnectionUpdate): Promise<Connection> {
    const connection = await this.findById(orgId, id);
    if (!connection) {
      throw new Error(`Connection ${id} not found`);
    }
    Object.assign(connection, data, { updatedAt: new Date() });
    return connection;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.connections.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Connection ${id} not found`);
    }
    this.connections.splice(index, 1);
  }
}

/**
 * Mock ExternalSystemIntegrationJobRepository for testing
 */export class MockExternalSystemIntegrationJobRepository implements ExternalSystemIntegrationJobRepository {
  private externalSystemIntegrationJobs: ExternalSystemIntegrationJob[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.externalSystemIntegrationJobs = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ExternalSystemIntegrationJob>> {
    let items = this.externalSystemIntegrationJobs.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ExternalSystemIntegrationJob | null> {
    return this.externalSystemIntegrationJobs.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ExternalSystemIntegrationJob | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EventSubscriptionRepository for testing
 */export class MockEventSubscriptionRepository implements EventSubscriptionRepository {
  private eventSubscriptions: EventSubscription[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.eventSubscriptions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListEventSubscriptionsParams
  ): Promise<PaginatedResult<EventSubscription>> {
    let items = this.eventSubscriptions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EventSubscription | null> {
    return this.eventSubscriptions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EventSubscription | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: EventSubscriptionInput): Promise<EventSubscription> {
    const eventSubscription: EventSubscription = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as EventSubscription;
    this.eventSubscriptions.push(eventSubscription);
    return eventSubscription;
  }

  async update(orgId: string, id: string, data: EventSubscriptionUpdate): Promise<EventSubscription> {
    const eventSubscription = await this.findById(orgId, id);
    if (!eventSubscription) {
      throw new Error(`EventSubscription ${id} not found`);
    }
    Object.assign(eventSubscription, data, { updatedAt: new Date() });
    return eventSubscription;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.eventSubscriptions.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`EventSubscription ${id} not found`);
    }
    this.eventSubscriptions.splice(index, 1);
  }
}

/**
 * Mock FhirbundleResourceRepository for testing
 */export class MockFhirbundleResourceRepository implements FhirbundleResourceRepository {
  private fhirbundleResources: FhirbundleResource[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.fhirbundleResources = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<FhirbundleResource>> {
    let items = this.fhirbundleResources.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<FhirbundleResource | null> {
    return this.fhirbundleResources.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<FhirbundleResource | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DataImportBatchRecordRepository for testing
 */export class MockDataImportBatchRecordRepository implements DataImportBatchRecordRepository {
  private dataImportBatchRecords: DataImportBatchRecord[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.dataImportBatchRecords = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DataImportBatchRecord>> {
    let items = this.dataImportBatchRecords.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DataImportBatchRecord | null> {
    return this.dataImportBatchRecords.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DataImportBatchRecord | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock IntegrationJobRunRepository for testing
 */export class MockIntegrationJobRunRepository implements IntegrationJobRunRepository {
  private integrationJobRuns: IntegrationJobRun[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.integrationJobRuns = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<IntegrationJobRun>> {
    let items = this.integrationJobRuns.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<IntegrationJobRun | null> {
    return this.integrationJobRuns.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<IntegrationJobRun | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock InterfaceHealthCheckRepository for testing
 */export class MockInterfaceHealthCheckRepository implements InterfaceHealthCheckRepository {
  private interfaceHealthChecks: InterfaceHealthCheck[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.interfaceHealthChecks = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: string
  ): Promise<PaginatedResult<InterfaceHealthCheck>> {
    let items = this.interfaceHealthChecks.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<InterfaceHealthCheck | null> {
    return this.interfaceHealthChecks.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<InterfaceHealthCheck | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CreateInterfaceHealthCheckRequest): Promise<InterfaceHealthCheck> {
    const interfaceHealthCheck: InterfaceHealthCheck = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as InterfaceHealthCheck;
    this.interfaceHealthChecks.push(interfaceHealthCheck);
    return interfaceHealthCheck;
  }
}

/**
 * Mock FhirbundleRepository for testing
 */export class MockFhirbundleRepository implements FhirbundleRepository {
  private fhirbundles: Fhirbundle[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.fhirbundles = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: string
  ): Promise<PaginatedResult<Fhirbundle>> {
    let items = this.fhirbundles.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Fhirbundle | null> {
    return this.fhirbundles.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Fhirbundle | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CreateFhirbundleRequest): Promise<Fhirbundle> {
    const fhirbundle: Fhirbundle = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Fhirbundle;
    this.fhirbundles.push(fhirbundle);
    return fhirbundle;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.fhirbundles.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Fhirbundle ${id} not found`);
    }
    this.fhirbundles.splice(index, 1);
  }
}

/**
 * Mock DataExportBatchFileRepository for testing
 */export class MockDataExportBatchFileRepository implements DataExportBatchFileRepository {
  private dataExportBatchFiles: DataExportBatchFile[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.dataExportBatchFiles = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DataExportBatchFile>> {
    let items = this.dataExportBatchFiles.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DataExportBatchFile | null> {
    return this.dataExportBatchFiles.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DataExportBatchFile | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ConnectionIntegrationJobRepository for testing
 */export class MockConnectionIntegrationJobRepository implements ConnectionIntegrationJobRepository {
  private connectionIntegrationJobs: ConnectionIntegrationJob[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.connectionIntegrationJobs = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ConnectionIntegrationJob>> {
    let items = this.connectionIntegrationJobs.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ConnectionIntegrationJob | null> {
    return this.connectionIntegrationJobs.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ConnectionIntegrationJob | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ApiclientCredentialRepository for testing
 */export class MockApiclientCredentialRepository implements ApiclientCredentialRepository {
  private apiclientCredentials: ApiclientCredential[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.apiclientCredentials = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ApiclientCredential>> {
    let items = this.apiclientCredentials.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ApiclientCredential | null> {
    return this.apiclientCredentials.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ApiclientCredential | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ConnectionHealthCheckRepository for testing
 */export class MockConnectionHealthCheckRepository implements ConnectionHealthCheckRepository {
  private connectionHealthChecks: ConnectionHealthCheck[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.connectionHealthChecks = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ConnectionHealthCheck>> {
    let items = this.connectionHealthChecks.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ConnectionHealthCheck | null> {
    return this.connectionHealthChecks.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ConnectionHealthCheck | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ExternalSystemRepository for testing
 */export class MockExternalSystemRepository implements ExternalSystemRepository {
  private externalSystems: ExternalSystem[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.externalSystems = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListExternalSystemsParams
  ): Promise<PaginatedResult<ExternalSystem>> {
    let items = this.externalSystems.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ExternalSystem | null> {
    return this.externalSystems.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ExternalSystem | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ExternalSystemInput): Promise<ExternalSystem> {
    const externalSystem: ExternalSystem = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ExternalSystem;
    this.externalSystems.push(externalSystem);
    return externalSystem;
  }

  async update(orgId: string, id: string, data: ExternalSystemUpdate): Promise<ExternalSystem> {
    const externalSystem = await this.findById(orgId, id);
    if (!externalSystem) {
      throw new Error(`ExternalSystem ${id} not found`);
    }
    Object.assign(externalSystem, data, { updatedAt: new Date() });
    return externalSystem;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.externalSystems.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ExternalSystem ${id} not found`);
    }
    this.externalSystems.splice(index, 1);
  }
}

/**
 * Mock ApiclientUsageMetricRepository for testing
 */export class MockApiclientUsageMetricRepository implements ApiclientUsageMetricRepository {
  private apiclientUsageMetrics: ApiclientUsageMetric[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.apiclientUsageMetrics = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ApiclientUsageMetric>> {
    let items = this.apiclientUsageMetrics.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ApiclientUsageMetric | null> {
    return this.apiclientUsageMetrics.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ApiclientUsageMetric | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DataImportBatchRepository for testing
 */export class MockDataImportBatchRepository implements DataImportBatchRepository {
  private dataImportBatchs: DataImportBatch[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.dataImportBatchs = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListDataImportBatchesParams
  ): Promise<PaginatedResult<DataImportBatch>> {
    let items = this.dataImportBatchs.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DataImportBatch | null> {
    return this.dataImportBatchs.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DataImportBatch | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: DataImportBatchInput): Promise<DataImportBatch> {
    const dataImportBatch: DataImportBatch = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as DataImportBatch;
    this.dataImportBatchs.push(dataImportBatch);
    return dataImportBatch;
  }

  async update(orgId: string, id: string, data: DataImportBatchUpdate): Promise<DataImportBatch> {
    const dataImportBatch = await this.findById(orgId, id);
    if (!dataImportBatch) {
      throw new Error(`DataImportBatch ${id} not found`);
    }
    Object.assign(dataImportBatch, data, { updatedAt: new Date() });
    return dataImportBatch;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.dataImportBatchs.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`DataImportBatch ${id} not found`);
    }
    this.dataImportBatchs.splice(index, 1);
  }
}

/**
 * Mock HlMappingProfileRuleRepository for testing
 */export class MockHlMappingProfileRuleRepository implements HlMappingProfileRuleRepository {
  private hlMappingProfileRules: HlMappingProfileRule[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.hlMappingProfileRules = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<HlMappingProfileRule>> {
    let items = this.hlMappingProfileRules.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<HlMappingProfileRule | null> {
    return this.hlMappingProfileRules.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<HlMappingProfileRule | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock IntegrationRunRepository for testing
 */export class MockIntegrationRunRepository implements IntegrationRunRepository {
  private integrationRuns: IntegrationRun[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.integrationRuns = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: string
  ): Promise<PaginatedResult<IntegrationRun>> {
    let items = this.integrationRuns.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<IntegrationRun | null> {
    return this.integrationRuns.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<IntegrationRun | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CreateIntegrationRunRequest): Promise<IntegrationRun> {
    const integrationRun: IntegrationRun = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as IntegrationRun;
    this.integrationRuns.push(integrationRun);
    return integrationRun;
  }
}

/**
 * Mock ExternalSystemConnectionRepository for testing
 */export class MockExternalSystemConnectionRepository implements ExternalSystemConnectionRepository {
  private externalSystemConnections: ExternalSystemConnection[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.externalSystemConnections = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ExternalSystemConnection>> {
    let items = this.externalSystemConnections.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ExternalSystemConnection | null> {
    return this.externalSystemConnections.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ExternalSystemConnection | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ApiclientRepository for testing
 */export class MockApiclientRepository implements ApiclientRepository {
  private apiclients: Apiclient[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.apiclients = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListAPIClientsParams
  ): Promise<PaginatedResult<Apiclient>> {
    let items = this.apiclients.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Apiclient | null> {
    return this.apiclients.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Apiclient | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: APIClientInput): Promise<Apiclient> {
    const apiclient: Apiclient = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Apiclient;
    this.apiclients.push(apiclient);
    return apiclient;
  }

  async update(orgId: string, id: string, data: APIClientUpdate): Promise<Apiclient> {
    const apiclient = await this.findById(orgId, id);
    if (!apiclient) {
      throw new Error(`Apiclient ${id} not found`);
    }
    Object.assign(apiclient, data, { updatedAt: new Date() });
    return apiclient;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.apiclients.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Apiclient ${id} not found`);
    }
    this.apiclients.splice(index, 1);
  }
}

/**
 * Mock ExternalSystemEndpointRepository for testing
 */export class MockExternalSystemEndpointRepository implements ExternalSystemEndpointRepository {
  private externalSystemEndpoints: ExternalSystemEndpoint[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.externalSystemEndpoints = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ExternalSystemEndpoint>> {
    let items = this.externalSystemEndpoints.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ExternalSystemEndpoint | null> {
    return this.externalSystemEndpoints.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ExternalSystemEndpoint | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DataExportBatchErrorRepository for testing
 */export class MockDataExportBatchErrorRepository implements DataExportBatchErrorRepository {
  private dataExportBatchErrors: DataExportBatchError[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.dataExportBatchErrors = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DataExportBatchError>> {
    let items = this.dataExportBatchErrors.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DataExportBatchError | null> {
    return this.dataExportBatchErrors.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DataExportBatchError | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DataExportBatchRepository for testing
 */export class MockDataExportBatchRepository implements DataExportBatchRepository {
  private dataExportBatchs: DataExportBatch[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.dataExportBatchs = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListDataExportBatchesParams
  ): Promise<PaginatedResult<DataExportBatch>> {
    let items = this.dataExportBatchs.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DataExportBatch | null> {
    return this.dataExportBatchs.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DataExportBatch | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: DataExportBatchInput): Promise<DataExportBatch> {
    const dataExportBatch: DataExportBatch = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as DataExportBatch;
    this.dataExportBatchs.push(dataExportBatch);
    return dataExportBatch;
  }

  async update(orgId: string, id: string, data: DataExportBatchUpdate): Promise<DataExportBatch> {
    const dataExportBatch = await this.findById(orgId, id);
    if (!dataExportBatch) {
      throw new Error(`DataExportBatch ${id} not found`);
    }
    Object.assign(dataExportBatch, data, { updatedAt: new Date() });
    return dataExportBatch;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.dataExportBatchs.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`DataExportBatch ${id} not found`);
    }
    this.dataExportBatchs.splice(index, 1);
  }
}

/**
 * Mock ApicredentialRepository for testing
 */export class MockApicredentialRepository implements ApicredentialRepository {
  private apicredentials: Apicredential[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.apicredentials = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListAPICredentialsParams
  ): Promise<PaginatedResult<Apicredential>> {
    let items = this.apicredentials.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Apicredential | null> {
    return this.apicredentials.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Apicredential | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: APICredentialInput): Promise<Apicredential> {
    const apicredential: Apicredential = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Apicredential;
    this.apicredentials.push(apicredential);
    return apicredential;
  }

  async update(orgId: string, id: string, data: APICredentialUpdate): Promise<Apicredential> {
    const apicredential = await this.findById(orgId, id);
    if (!apicredential) {
      throw new Error(`Apicredential ${id} not found`);
    }
    Object.assign(apicredential, data, { updatedAt: new Date() });
    return apicredential;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.apicredentials.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Apicredential ${id} not found`);
    }
    this.apicredentials.splice(index, 1);
  }
}

/**
 * Mock HlMessageSegmentRepository for testing
 */export class MockHlMessageSegmentRepository implements HlMessageSegmentRepository {
  private hlMessageSegments: HlMessageSegment[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.hlMessageSegments = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<HlMessageSegment>> {
    let items = this.hlMessageSegments.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<HlMessageSegment | null> {
    return this.hlMessageSegments.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<HlMessageSegment | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock IntegrationRunErrorRepository for testing
 */export class MockIntegrationRunErrorRepository implements IntegrationRunErrorRepository {
  private integrationRunErrors: IntegrationRunError[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.integrationRunErrors = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<IntegrationRunError>> {
    let items = this.integrationRunErrors.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<IntegrationRunError | null> {
    return this.integrationRunErrors.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<IntegrationRunError | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock FhirmappingProfileRuleRepository for testing
 */export class MockFhirmappingProfileRuleRepository implements FhirmappingProfileRuleRepository {
  private fhirmappingProfileRules: FhirmappingProfileRule[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.fhirmappingProfileRules = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<FhirmappingProfileRule>> {
    let items = this.fhirmappingProfileRules.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<FhirmappingProfileRule | null> {
    return this.fhirmappingProfileRules.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<FhirmappingProfileRule | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EventDeliveryRepository for testing
 */export class MockEventDeliveryRepository implements EventDeliveryRepository {
  private eventDeliverys: EventDelivery[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.eventDeliverys = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: EventDeliveryUpdate
  ): Promise<PaginatedResult<EventDelivery>> {
    let items = this.eventDeliverys.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EventDelivery | null> {
    return this.eventDeliverys.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EventDelivery | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CreateEventDeliveryRequest): Promise<EventDelivery> {
    const eventDelivery: EventDelivery = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as EventDelivery;
    this.eventDeliverys.push(eventDelivery);
    return eventDelivery;
  }

  async update(orgId: string, id: string, data: UpdateEventDeliveryRequest): Promise<EventDelivery> {
    const eventDelivery = await this.findById(orgId, id);
    if (!eventDelivery) {
      throw new Error(`EventDelivery ${id} not found`);
    }
    Object.assign(eventDelivery, data, { updatedAt: new Date() });
    return eventDelivery;
  }
}

/**
 * Mock HlMessageRepository for testing
 */export class MockHlMessageRepository implements HlMessageRepository {
  private hlMessages: HlMessage[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.hlMessages = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: string
  ): Promise<PaginatedResult<HlMessage>> {
    let items = this.hlMessages.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<HlMessage | null> {
    return this.hlMessages.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<HlMessage | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CreateHlMessageRequest): Promise<HlMessage> {
    const hlMessage: HlMessage = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as HlMessage;
    this.hlMessages.push(hlMessage);
    return hlMessage;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.hlMessages.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`HlMessage ${id} not found`);
    }
    this.hlMessages.splice(index, 1);
  }
}

/**
 * Mock InterfaceErrorRepository for testing
 */export class MockInterfaceErrorRepository implements InterfaceErrorRepository {
  private interfaceErrors: InterfaceError[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.interfaceErrors = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: InterfaceErrorUpdate
  ): Promise<PaginatedResult<InterfaceError>> {
    let items = this.interfaceErrors.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<InterfaceError | null> {
    return this.interfaceErrors.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<InterfaceError | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CreateInterfaceErrorRequest): Promise<InterfaceError> {
    const interfaceError: InterfaceError = {
      ...data,
      id: iiTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as InterfaceError;
    this.interfaceErrors.push(interfaceError);
    return interfaceError;
  }

  async update(orgId: string, id: string, data: UpdateInterfaceErrorRequest): Promise<InterfaceError> {
    const interfaceError = await this.findById(orgId, id);
    if (!interfaceError) {
      throw new Error(`InterfaceError ${id} not found`);
    }
    Object.assign(interfaceError, data, { updatedAt: new Date() });
    return interfaceError;
  }
}

/**
 * Mock IntegrationRunLogRepository for testing
 */export class MockIntegrationRunLogRepository implements IntegrationRunLogRepository {
  private integrationRunLogs: IntegrationRunLog[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.integrationRunLogs = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<IntegrationRunLog>> {
    let items = this.integrationRunLogs.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<IntegrationRunLog | null> {
    return this.integrationRunLogs.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<IntegrationRunLog | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DataImportBatchErrorRepository for testing
 */export class MockDataImportBatchErrorRepository implements DataImportBatchErrorRepository {
  private dataImportBatchErrors: DataImportBatchError[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.dataImportBatchErrors = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DataImportBatchError>> {
    let items = this.dataImportBatchErrors.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DataImportBatchError | null> {
    return this.dataImportBatchErrors.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DataImportBatchError | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EventSubscriptionDeliveryRepository for testing
 */export class MockEventSubscriptionDeliveryRepository implements EventSubscriptionDeliveryRepository {
  private eventSubscriptionDeliverys: EventSubscriptionDelivery[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.eventSubscriptionDeliverys = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<EventSubscriptionDelivery>> {
    let items = this.eventSubscriptionDeliverys.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EventSubscriptionDelivery | null> {
    return this.eventSubscriptionDeliverys.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EventSubscriptionDelivery | null> {
    return this.findById(orgId, id);
  }
}

