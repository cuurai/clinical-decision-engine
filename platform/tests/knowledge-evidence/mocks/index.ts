/**
 * Mock Repositories for Testing
 *
 * Generated by Test Generator v1.0.0
 * Generator Version: 1.0.0
 * Domain: knowledge-evidence
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated. Any manual changes will be overwritten.
 */

import type {
  OrderSetTemplateRepository,
  KnowledgePackageClinicalRuleRepository,
  QuestionnaireTemplateRepository,
  QuestionnaireTemplateQuestionRepository,
  EvidenceCitationRepository,
  OntologyTermChildRepository,
  ScoringTemplateItemRepository,
  OntologyTermParentRepository,
  CareProtocolStepRepository,
  EvidenceReviewRepository,
  CareProtocolRepository,
  ClinicalRuleRepository,
  ModelVersionTestRepository,
  ModelVersionRepository,
  GuidelineRepository,
  ClinicalRuleTestRepository,
  ModelDefinitionVersionRepository,
  OrderSetTemplateItemRepository,
  ScoringTemplateRepository,
  GuidelineSectionRepository,
  ConceptMapRepository,
  GuidelineEvidenceCitationRepository,
  ValueSetRepository,
  ModelDefinitionPerformanceMetricRepository,
  CareProtocolOrderSetRepository,
  OntologyTermRepository,
  ConceptMapMappingRepository,
  KnowledgePackageModelDefinitionRepository,
  KnowledgePackageValueSetRepository,
  RuleSetClinicalRuleRepository,
  ClinicalRuleVersionRepository,
  ModelDefinitionRepository,
  ModelVersionFeatureDefinitionRepository,
  RuleSetRepository,
  OntologyTermMappingRepository,
  ValueSetCodeRepository,
  KnowledgePackageRepository,
} from "@cuur-cde/core/knowledge-evidence/repositories/index.js";
import type {
  CareProtocol,
  CareProtocolOrderSet,
  CareProtocolStep,
  ClinicalRule,
  ClinicalRuleTest,
  ClinicalRuleVersion,
  ConceptMap,
  ConceptMapMapping,
  EvidenceCitation,
  EvidenceReview,
  Guideline,
  GuidelineEvidenceCitation,
  GuidelineSection,
  KnowledgePackage,
  KnowledgePackageClinicalRule,
  KnowledgePackageModelDefinition,
  KnowledgePackageValueSet,
  ModelDefinition,
  ModelDefinitionPerformanceMetric,
  ModelDefinitionVersion,
  ModelVersion,
  ModelVersionFeatureDefinition,
  ModelVersionTest,
  OntologyTerm,
  OntologyTermChild,
  OntologyTermMapping,
  OntologyTermParent,
  OrderSetTemplate,
  OrderSetTemplateItem,
  QuestionnaireTemplate,
  QuestionnaireTemplateQuestion,
  RuleSet,
  RuleSetClinicalRule,
  ScoringTemplate,
  ScoringTemplateItem,
  ValueSet,
  ValueSetCode,
  CareProtocolTemplateInput,
  ClinicalGuidelineInput,
  ClinicalRuleInput,
  ConceptMapInput,
  EvidenceCitationInput,
  EvidenceReviewInput,
  KnowledgePackageInput,
  ModelDefinitionInput,
  ModelVersionInput,
  OrderSetTemplateInput,
  QuestionnaireTemplateInput,
  RuleSetInput,
  ScoringTemplateInput,
  ValueSetInput,
  CareProtocolTemplateUpdate,
  ClinicalGuidelineUpdate,
  ClinicalRuleUpdate,
  ConceptMapUpdate,
  EvidenceCitationUpdate,
  EvidenceReviewUpdate,
  KnowledgePackageUpdate,
  ModelDefinitionUpdate,
  ModelVersionUpdate,
  OrderSetTemplateUpdate,
  QuestionnaireTemplateUpdate,
  RuleSetUpdate,
  ScoringTemplateUpdate,
  ValueSetUpdate,
} from "@cuur-cde/core/knowledge-evidence/types/index.js";
import type {
  ListCareProtocolsParams,
  ListClinicalRulesParams,
  ListConceptMapsParams,
  ListEvidenceCitationsParams,
  ListEvidenceReviewsParams,
  ListGuidelinesParams,
  ListKnowledgePackagesParams,
  ListModelDefinitionsParams,
  ListModelVersionsParams,
  ListOrderSetTemplatesParams,
  ListQuestionnaireTemplatesParams,
  ListRuleSetsParams,
  ListScoringTemplatesParams,
  ListValueSetsParams,
  PaginationParams,
  SearchOntologyTermsParams,
  PaginatedResult,
} from "@cuur-cde/core/shared/helpers/index.js";
import { keTransactionId } from "@cuur-cde/core/shared/helpers/id-generator.js";


/**
 * Mock OrderSetTemplateRepository for testing
 */export class MockOrderSetTemplateRepository implements OrderSetTemplateRepository {
  private orderSetTemplates: OrderSetTemplate[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.orderSetTemplates = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListOrderSetTemplatesParams
  ): Promise<PaginatedResult<OrderSetTemplate>> {
    let items = this.orderSetTemplates.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<OrderSetTemplate | null> {
    return this.orderSetTemplates.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<OrderSetTemplate | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: OrderSetTemplateInput): Promise<OrderSetTemplate> {
    const orderSetTemplate: OrderSetTemplate = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as OrderSetTemplate;
    this.orderSetTemplates.push(orderSetTemplate);
    return orderSetTemplate;
  }

  async update(orgId: string, id: string, data: OrderSetTemplateUpdate): Promise<OrderSetTemplate> {
    const orderSetTemplate = await this.findById(orgId, id);
    if (!orderSetTemplate) {
      throw new Error(`OrderSetTemplate ${id} not found`);
    }
    Object.assign(orderSetTemplate, data, { updatedAt: new Date() });
    return orderSetTemplate;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.orderSetTemplates.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`OrderSetTemplate ${id} not found`);
    }
    this.orderSetTemplates.splice(index, 1);
  }
}

/**
 * Mock KnowledgePackageClinicalRuleRepository for testing
 */export class MockKnowledgePackageClinicalRuleRepository implements KnowledgePackageClinicalRuleRepository {
  private knowledgePackageClinicalRules: KnowledgePackageClinicalRule[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.knowledgePackageClinicalRules = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<KnowledgePackageClinicalRule>> {
    let items = this.knowledgePackageClinicalRules.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<KnowledgePackageClinicalRule | null> {
    return this.knowledgePackageClinicalRules.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<KnowledgePackageClinicalRule | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock QuestionnaireTemplateRepository for testing
 */export class MockQuestionnaireTemplateRepository implements QuestionnaireTemplateRepository {
  private questionnaireTemplates: QuestionnaireTemplate[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.questionnaireTemplates = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListQuestionnaireTemplatesParams
  ): Promise<PaginatedResult<QuestionnaireTemplate>> {
    let items = this.questionnaireTemplates.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<QuestionnaireTemplate | null> {
    return this.questionnaireTemplates.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<QuestionnaireTemplate | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: QuestionnaireTemplateInput): Promise<QuestionnaireTemplate> {
    const questionnaireTemplate: QuestionnaireTemplate = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as QuestionnaireTemplate;
    this.questionnaireTemplates.push(questionnaireTemplate);
    return questionnaireTemplate;
  }

  async update(orgId: string, id: string, data: QuestionnaireTemplateUpdate): Promise<QuestionnaireTemplate> {
    const questionnaireTemplate = await this.findById(orgId, id);
    if (!questionnaireTemplate) {
      throw new Error(`QuestionnaireTemplate ${id} not found`);
    }
    Object.assign(questionnaireTemplate, data, { updatedAt: new Date() });
    return questionnaireTemplate;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.questionnaireTemplates.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`QuestionnaireTemplate ${id} not found`);
    }
    this.questionnaireTemplates.splice(index, 1);
  }
}

/**
 * Mock QuestionnaireTemplateQuestionRepository for testing
 */export class MockQuestionnaireTemplateQuestionRepository implements QuestionnaireTemplateQuestionRepository {
  private questionnaireTemplateQuestions: QuestionnaireTemplateQuestion[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.questionnaireTemplateQuestions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<QuestionnaireTemplateQuestion>> {
    let items = this.questionnaireTemplateQuestions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<QuestionnaireTemplateQuestion | null> {
    return this.questionnaireTemplateQuestions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<QuestionnaireTemplateQuestion | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EvidenceCitationRepository for testing
 */export class MockEvidenceCitationRepository implements EvidenceCitationRepository {
  private evidenceCitations: EvidenceCitation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.evidenceCitations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListEvidenceCitationsParams
  ): Promise<PaginatedResult<EvidenceCitation>> {
    let items = this.evidenceCitations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EvidenceCitation | null> {
    return this.evidenceCitations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EvidenceCitation | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: EvidenceCitationInput): Promise<EvidenceCitation> {
    const evidenceCitation: EvidenceCitation = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as EvidenceCitation;
    this.evidenceCitations.push(evidenceCitation);
    return evidenceCitation;
  }

  async update(orgId: string, id: string, data: EvidenceCitationUpdate): Promise<EvidenceCitation> {
    const evidenceCitation = await this.findById(orgId, id);
    if (!evidenceCitation) {
      throw new Error(`EvidenceCitation ${id} not found`);
    }
    Object.assign(evidenceCitation, data, { updatedAt: new Date() });
    return evidenceCitation;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.evidenceCitations.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`EvidenceCitation ${id} not found`);
    }
    this.evidenceCitations.splice(index, 1);
  }
}

/**
 * Mock OntologyTermChildRepository for testing
 */export class MockOntologyTermChildRepository implements OntologyTermChildRepository {
  private ontologyTermChilds: OntologyTermChild[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.ontologyTermChilds = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<OntologyTermChild>> {
    let items = this.ontologyTermChilds.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<OntologyTermChild | null> {
    return this.ontologyTermChilds.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<OntologyTermChild | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ScoringTemplateItemRepository for testing
 */export class MockScoringTemplateItemRepository implements ScoringTemplateItemRepository {
  private scoringTemplateItems: ScoringTemplateItem[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.scoringTemplateItems = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ScoringTemplateItem>> {
    let items = this.scoringTemplateItems.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ScoringTemplateItem | null> {
    return this.scoringTemplateItems.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ScoringTemplateItem | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock OntologyTermParentRepository for testing
 */export class MockOntologyTermParentRepository implements OntologyTermParentRepository {
  private ontologyTermParents: OntologyTermParent[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.ontologyTermParents = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<OntologyTermParent>> {
    let items = this.ontologyTermParents.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<OntologyTermParent | null> {
    return this.ontologyTermParents.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<OntologyTermParent | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock CareProtocolStepRepository for testing
 */export class MockCareProtocolStepRepository implements CareProtocolStepRepository {
  private careProtocolSteps: CareProtocolStep[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.careProtocolSteps = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<CareProtocolStep>> {
    let items = this.careProtocolSteps.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CareProtocolStep | null> {
    return this.careProtocolSteps.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CareProtocolStep | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EvidenceReviewRepository for testing
 */export class MockEvidenceReviewRepository implements EvidenceReviewRepository {
  private evidenceReviews: EvidenceReview[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.evidenceReviews = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListEvidenceReviewsParams
  ): Promise<PaginatedResult<EvidenceReview>> {
    let items = this.evidenceReviews.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EvidenceReview | null> {
    return this.evidenceReviews.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EvidenceReview | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: EvidenceReviewInput): Promise<EvidenceReview> {
    const evidenceReview: EvidenceReview = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as EvidenceReview;
    this.evidenceReviews.push(evidenceReview);
    return evidenceReview;
  }

  async update(orgId: string, id: string, data: EvidenceReviewUpdate): Promise<EvidenceReview> {
    const evidenceReview = await this.findById(orgId, id);
    if (!evidenceReview) {
      throw new Error(`EvidenceReview ${id} not found`);
    }
    Object.assign(evidenceReview, data, { updatedAt: new Date() });
    return evidenceReview;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.evidenceReviews.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`EvidenceReview ${id} not found`);
    }
    this.evidenceReviews.splice(index, 1);
  }
}

/**
 * Mock CareProtocolRepository for testing
 */export class MockCareProtocolRepository implements CareProtocolRepository {
  private careProtocols: CareProtocol[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.careProtocols = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListCareProtocolsParams
  ): Promise<PaginatedResult<CareProtocol>> {
    let items = this.careProtocols.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CareProtocol | null> {
    return this.careProtocols.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CareProtocol | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CareProtocolTemplateInput): Promise<CareProtocol> {
    const careProtocol: CareProtocol = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as CareProtocol;
    this.careProtocols.push(careProtocol);
    return careProtocol;
  }

  async update(orgId: string, id: string, data: CareProtocolTemplateUpdate): Promise<CareProtocol> {
    const careProtocol = await this.findById(orgId, id);
    if (!careProtocol) {
      throw new Error(`CareProtocol ${id} not found`);
    }
    Object.assign(careProtocol, data, { updatedAt: new Date() });
    return careProtocol;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.careProtocols.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`CareProtocol ${id} not found`);
    }
    this.careProtocols.splice(index, 1);
  }
}

/**
 * Mock ClinicalRuleRepository for testing
 */export class MockClinicalRuleRepository implements ClinicalRuleRepository {
  private clinicalRules: ClinicalRule[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.clinicalRules = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListClinicalRulesParams
  ): Promise<PaginatedResult<ClinicalRule>> {
    let items = this.clinicalRules.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ClinicalRule | null> {
    return this.clinicalRules.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ClinicalRule | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ClinicalRuleInput): Promise<ClinicalRule> {
    const clinicalRule: ClinicalRule = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ClinicalRule;
    this.clinicalRules.push(clinicalRule);
    return clinicalRule;
  }

  async update(orgId: string, id: string, data: ClinicalRuleUpdate): Promise<ClinicalRule> {
    const clinicalRule = await this.findById(orgId, id);
    if (!clinicalRule) {
      throw new Error(`ClinicalRule ${id} not found`);
    }
    Object.assign(clinicalRule, data, { updatedAt: new Date() });
    return clinicalRule;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.clinicalRules.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ClinicalRule ${id} not found`);
    }
    this.clinicalRules.splice(index, 1);
  }
}

/**
 * Mock ModelVersionTestRepository for testing
 */export class MockModelVersionTestRepository implements ModelVersionTestRepository {
  private modelVersionTests: ModelVersionTest[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.modelVersionTests = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ModelVersionTest>> {
    let items = this.modelVersionTests.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ModelVersionTest | null> {
    return this.modelVersionTests.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ModelVersionTest | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ModelVersionRepository for testing
 */export class MockModelVersionRepository implements ModelVersionRepository {
  private modelVersions: ModelVersion[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.modelVersions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListModelVersionsParams
  ): Promise<PaginatedResult<ModelVersion>> {
    let items = this.modelVersions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ModelVersion | null> {
    return this.modelVersions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ModelVersion | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ModelVersionInput): Promise<ModelVersion> {
    const modelVersion: ModelVersion = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ModelVersion;
    this.modelVersions.push(modelVersion);
    return modelVersion;
  }

  async update(orgId: string, id: string, data: ModelVersionUpdate): Promise<ModelVersion> {
    const modelVersion = await this.findById(orgId, id);
    if (!modelVersion) {
      throw new Error(`ModelVersion ${id} not found`);
    }
    Object.assign(modelVersion, data, { updatedAt: new Date() });
    return modelVersion;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.modelVersions.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ModelVersion ${id} not found`);
    }
    this.modelVersions.splice(index, 1);
  }
}

/**
 * Mock GuidelineRepository for testing
 */export class MockGuidelineRepository implements GuidelineRepository {
  private guidelines: Guideline[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.guidelines = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListGuidelinesParams
  ): Promise<PaginatedResult<Guideline>> {
    let items = this.guidelines.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Guideline | null> {
    return this.guidelines.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Guideline | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ClinicalGuidelineInput): Promise<Guideline> {
    const guideline: Guideline = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Guideline;
    this.guidelines.push(guideline);
    return guideline;
  }

  async update(orgId: string, id: string, data: ClinicalGuidelineUpdate): Promise<Guideline> {
    const guideline = await this.findById(orgId, id);
    if (!guideline) {
      throw new Error(`Guideline ${id} not found`);
    }
    Object.assign(guideline, data, { updatedAt: new Date() });
    return guideline;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.guidelines.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Guideline ${id} not found`);
    }
    this.guidelines.splice(index, 1);
  }
}

/**
 * Mock ClinicalRuleTestRepository for testing
 */export class MockClinicalRuleTestRepository implements ClinicalRuleTestRepository {
  private clinicalRuleTests: ClinicalRuleTest[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.clinicalRuleTests = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ClinicalRuleTest>> {
    let items = this.clinicalRuleTests.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ClinicalRuleTest | null> {
    return this.clinicalRuleTests.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ClinicalRuleTest | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ModelDefinitionVersionRepository for testing
 */export class MockModelDefinitionVersionRepository implements ModelDefinitionVersionRepository {
  private modelDefinitionVersions: ModelDefinitionVersion[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.modelDefinitionVersions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ModelDefinitionVersion>> {
    let items = this.modelDefinitionVersions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ModelDefinitionVersion | null> {
    return this.modelDefinitionVersions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ModelDefinitionVersion | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock OrderSetTemplateItemRepository for testing
 */export class MockOrderSetTemplateItemRepository implements OrderSetTemplateItemRepository {
  private orderSetTemplateItems: OrderSetTemplateItem[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.orderSetTemplateItems = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<OrderSetTemplateItem>> {
    let items = this.orderSetTemplateItems.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<OrderSetTemplateItem | null> {
    return this.orderSetTemplateItems.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<OrderSetTemplateItem | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ScoringTemplateRepository for testing
 */export class MockScoringTemplateRepository implements ScoringTemplateRepository {
  private scoringTemplates: ScoringTemplate[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.scoringTemplates = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListScoringTemplatesParams
  ): Promise<PaginatedResult<ScoringTemplate>> {
    let items = this.scoringTemplates.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ScoringTemplate | null> {
    return this.scoringTemplates.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ScoringTemplate | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ScoringTemplateInput): Promise<ScoringTemplate> {
    const scoringTemplate: ScoringTemplate = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ScoringTemplate;
    this.scoringTemplates.push(scoringTemplate);
    return scoringTemplate;
  }

  async update(orgId: string, id: string, data: ScoringTemplateUpdate): Promise<ScoringTemplate> {
    const scoringTemplate = await this.findById(orgId, id);
    if (!scoringTemplate) {
      throw new Error(`ScoringTemplate ${id} not found`);
    }
    Object.assign(scoringTemplate, data, { updatedAt: new Date() });
    return scoringTemplate;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.scoringTemplates.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ScoringTemplate ${id} not found`);
    }
    this.scoringTemplates.splice(index, 1);
  }
}

/**
 * Mock GuidelineSectionRepository for testing
 */export class MockGuidelineSectionRepository implements GuidelineSectionRepository {
  private guidelineSections: GuidelineSection[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.guidelineSections = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<GuidelineSection>> {
    let items = this.guidelineSections.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<GuidelineSection | null> {
    return this.guidelineSections.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<GuidelineSection | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ConceptMapRepository for testing
 */export class MockConceptMapRepository implements ConceptMapRepository {
  private conceptMaps: ConceptMap[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.conceptMaps = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListConceptMapsParams
  ): Promise<PaginatedResult<ConceptMap>> {
    let items = this.conceptMaps.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ConceptMap | null> {
    return this.conceptMaps.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ConceptMap | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ConceptMapInput): Promise<ConceptMap> {
    const conceptMap: ConceptMap = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ConceptMap;
    this.conceptMaps.push(conceptMap);
    return conceptMap;
  }

  async update(orgId: string, id: string, data: ConceptMapUpdate): Promise<ConceptMap> {
    const conceptMap = await this.findById(orgId, id);
    if (!conceptMap) {
      throw new Error(`ConceptMap ${id} not found`);
    }
    Object.assign(conceptMap, data, { updatedAt: new Date() });
    return conceptMap;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.conceptMaps.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ConceptMap ${id} not found`);
    }
    this.conceptMaps.splice(index, 1);
  }
}

/**
 * Mock GuidelineEvidenceCitationRepository for testing
 */export class MockGuidelineEvidenceCitationRepository implements GuidelineEvidenceCitationRepository {
  private guidelineEvidenceCitations: GuidelineEvidenceCitation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.guidelineEvidenceCitations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<GuidelineEvidenceCitation>> {
    let items = this.guidelineEvidenceCitations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<GuidelineEvidenceCitation | null> {
    return this.guidelineEvidenceCitations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<GuidelineEvidenceCitation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ValueSetRepository for testing
 */export class MockValueSetRepository implements ValueSetRepository {
  private valueSets: ValueSet[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.valueSets = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListValueSetsParams
  ): Promise<PaginatedResult<ValueSet>> {
    let items = this.valueSets.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ValueSet | null> {
    return this.valueSets.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ValueSet | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ValueSetInput): Promise<ValueSet> {
    const valueSet: ValueSet = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ValueSet;
    this.valueSets.push(valueSet);
    return valueSet;
  }

  async update(orgId: string, id: string, data: ValueSetUpdate): Promise<ValueSet> {
    const valueSet = await this.findById(orgId, id);
    if (!valueSet) {
      throw new Error(`ValueSet ${id} not found`);
    }
    Object.assign(valueSet, data, { updatedAt: new Date() });
    return valueSet;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.valueSets.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ValueSet ${id} not found`);
    }
    this.valueSets.splice(index, 1);
  }
}

/**
 * Mock ModelDefinitionPerformanceMetricRepository for testing
 */export class MockModelDefinitionPerformanceMetricRepository implements ModelDefinitionPerformanceMetricRepository {
  private modelDefinitionPerformanceMetrics: ModelDefinitionPerformanceMetric[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.modelDefinitionPerformanceMetrics = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ModelDefinitionPerformanceMetric>> {
    let items = this.modelDefinitionPerformanceMetrics.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ModelDefinitionPerformanceMetric | null> {
    return this.modelDefinitionPerformanceMetrics.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ModelDefinitionPerformanceMetric | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock CareProtocolOrderSetRepository for testing
 */export class MockCareProtocolOrderSetRepository implements CareProtocolOrderSetRepository {
  private careProtocolOrderSets: CareProtocolOrderSet[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.careProtocolOrderSets = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<CareProtocolOrderSet>> {
    let items = this.careProtocolOrderSets.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CareProtocolOrderSet | null> {
    return this.careProtocolOrderSets.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CareProtocolOrderSet | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock OntologyTermRepository for testing
 */export class MockOntologyTermRepository implements OntologyTermRepository {
  private ontologyTerms: OntologyTerm[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.ontologyTerms = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: SearchOntologyTermsParams
  ): Promise<PaginatedResult<OntologyTerm>> {
    let items = this.ontologyTerms.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<OntologyTerm | null> {
    return this.ontologyTerms.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<OntologyTerm | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ConceptMapMappingRepository for testing
 */export class MockConceptMapMappingRepository implements ConceptMapMappingRepository {
  private conceptMapMappings: ConceptMapMapping[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.conceptMapMappings = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ConceptMapMapping>> {
    let items = this.conceptMapMappings.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ConceptMapMapping | null> {
    return this.conceptMapMappings.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ConceptMapMapping | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock KnowledgePackageModelDefinitionRepository for testing
 */export class MockKnowledgePackageModelDefinitionRepository implements KnowledgePackageModelDefinitionRepository {
  private knowledgePackageModelDefinitions: KnowledgePackageModelDefinition[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.knowledgePackageModelDefinitions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<KnowledgePackageModelDefinition>> {
    let items = this.knowledgePackageModelDefinitions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<KnowledgePackageModelDefinition | null> {
    return this.knowledgePackageModelDefinitions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<KnowledgePackageModelDefinition | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock KnowledgePackageValueSetRepository for testing
 */export class MockKnowledgePackageValueSetRepository implements KnowledgePackageValueSetRepository {
  private knowledgePackageValueSets: KnowledgePackageValueSet[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.knowledgePackageValueSets = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<KnowledgePackageValueSet>> {
    let items = this.knowledgePackageValueSets.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<KnowledgePackageValueSet | null> {
    return this.knowledgePackageValueSets.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<KnowledgePackageValueSet | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock RuleSetClinicalRuleRepository for testing
 */export class MockRuleSetClinicalRuleRepository implements RuleSetClinicalRuleRepository {
  private ruleSetClinicalRules: RuleSetClinicalRule[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.ruleSetClinicalRules = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<RuleSetClinicalRule>> {
    let items = this.ruleSetClinicalRules.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<RuleSetClinicalRule | null> {
    return this.ruleSetClinicalRules.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<RuleSetClinicalRule | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ClinicalRuleVersionRepository for testing
 */export class MockClinicalRuleVersionRepository implements ClinicalRuleVersionRepository {
  private clinicalRuleVersions: ClinicalRuleVersion[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.clinicalRuleVersions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ClinicalRuleVersion>> {
    let items = this.clinicalRuleVersions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ClinicalRuleVersion | null> {
    return this.clinicalRuleVersions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ClinicalRuleVersion | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ModelDefinitionRepository for testing
 */export class MockModelDefinitionRepository implements ModelDefinitionRepository {
  private modelDefinitions: ModelDefinition[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.modelDefinitions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListModelDefinitionsParams
  ): Promise<PaginatedResult<ModelDefinition>> {
    let items = this.modelDefinitions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ModelDefinition | null> {
    return this.modelDefinitions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ModelDefinition | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ModelDefinitionInput): Promise<ModelDefinition> {
    const modelDefinition: ModelDefinition = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ModelDefinition;
    this.modelDefinitions.push(modelDefinition);
    return modelDefinition;
  }

  async update(orgId: string, id: string, data: ModelDefinitionUpdate): Promise<ModelDefinition> {
    const modelDefinition = await this.findById(orgId, id);
    if (!modelDefinition) {
      throw new Error(`ModelDefinition ${id} not found`);
    }
    Object.assign(modelDefinition, data, { updatedAt: new Date() });
    return modelDefinition;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.modelDefinitions.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ModelDefinition ${id} not found`);
    }
    this.modelDefinitions.splice(index, 1);
  }
}

/**
 * Mock ModelVersionFeatureDefinitionRepository for testing
 */export class MockModelVersionFeatureDefinitionRepository implements ModelVersionFeatureDefinitionRepository {
  private modelVersionFeatureDefinitions: ModelVersionFeatureDefinition[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.modelVersionFeatureDefinitions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ModelVersionFeatureDefinition>> {
    let items = this.modelVersionFeatureDefinitions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ModelVersionFeatureDefinition | null> {
    return this.modelVersionFeatureDefinitions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ModelVersionFeatureDefinition | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock RuleSetRepository for testing
 */export class MockRuleSetRepository implements RuleSetRepository {
  private ruleSets: RuleSet[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.ruleSets = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListRuleSetsParams
  ): Promise<PaginatedResult<RuleSet>> {
    let items = this.ruleSets.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<RuleSet | null> {
    return this.ruleSets.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<RuleSet | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: RuleSetInput): Promise<RuleSet> {
    const ruleSet: RuleSet = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as RuleSet;
    this.ruleSets.push(ruleSet);
    return ruleSet;
  }

  async update(orgId: string, id: string, data: RuleSetUpdate): Promise<RuleSet> {
    const ruleSet = await this.findById(orgId, id);
    if (!ruleSet) {
      throw new Error(`RuleSet ${id} not found`);
    }
    Object.assign(ruleSet, data, { updatedAt: new Date() });
    return ruleSet;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.ruleSets.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`RuleSet ${id} not found`);
    }
    this.ruleSets.splice(index, 1);
  }
}

/**
 * Mock OntologyTermMappingRepository for testing
 */export class MockOntologyTermMappingRepository implements OntologyTermMappingRepository {
  private ontologyTermMappings: OntologyTermMapping[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.ontologyTermMappings = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<OntologyTermMapping>> {
    let items = this.ontologyTermMappings.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<OntologyTermMapping | null> {
    return this.ontologyTermMappings.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<OntologyTermMapping | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ValueSetCodeRepository for testing
 */export class MockValueSetCodeRepository implements ValueSetCodeRepository {
  private valueSetCodes: ValueSetCode[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.valueSetCodes = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ValueSetCode>> {
    let items = this.valueSetCodes.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ValueSetCode | null> {
    return this.valueSetCodes.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ValueSetCode | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock KnowledgePackageRepository for testing
 */export class MockKnowledgePackageRepository implements KnowledgePackageRepository {
  private knowledgePackages: KnowledgePackage[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.knowledgePackages = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListKnowledgePackagesParams
  ): Promise<PaginatedResult<KnowledgePackage>> {
    let items = this.knowledgePackages.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<KnowledgePackage | null> {
    return this.knowledgePackages.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<KnowledgePackage | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: KnowledgePackageInput): Promise<KnowledgePackage> {
    const knowledgePackage: KnowledgePackage = {
      ...data,
      id: keTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as KnowledgePackage;
    this.knowledgePackages.push(knowledgePackage);
    return knowledgePackage;
  }

  async update(orgId: string, id: string, data: KnowledgePackageUpdate): Promise<KnowledgePackage> {
    const knowledgePackage = await this.findById(orgId, id);
    if (!knowledgePackage) {
      throw new Error(`KnowledgePackage ${id} not found`);
    }
    Object.assign(knowledgePackage, data, { updatedAt: new Date() });
    return knowledgePackage;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.knowledgePackages.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`KnowledgePackage ${id} not found`);
    }
    this.knowledgePackages.splice(index, 1);
  }
}

