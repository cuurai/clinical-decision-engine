/**
 * Mock Repositories for Testing
 *
 * Generated by Test Generator v1.0.0
 * Generator Version: 1.0.0
 * Domain: workflow-care-pathways
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated. Any manual changes will be overwritten.
 */

import type {
  WorkQueueRepository,
  WorkflowDefinitionTransitionRepository,
  WorkflowDefinitionStateRepository,
  TaskCommentRepository,
  CarePathwayTemplateOrderSetTemplateRepository,
  AlertRepository,
  WorkflowInstanceRepository,
  EscalationPolicyRepository,
  EpisodeOfCareWorkflowInstanceRepository,
  TaskAssignmentRepository,
  ChecklistTemplateItemRepository,
  WorkflowDefinitionRepository,
  EpisodesOfCareRepository,
  CarePlanGoalRepository,
  HandoffRepository,
  AlertAuditEventRepository,
  RoutingRuleRepository,
  TaskAuditEventRepository,
  EpisodeOfCareCarePlanRepository,
  CarePlanChecklistRepository,
  WorkQueueAlertRepository,
  CarePathwayTemplateStepRepository,
  CarePlanRepository,
  WorkflowInstanceTaskRepository,
  WorkflowInstanceEventRepository,
  ScheduleTemplateRepository,
  EscalationPolicyRuleRepository,
  CarePathwayTemplateRepository,
  ChecklistInstanceItemRepository,
  WorkQueueTaskRepository,
  WorkflowInstanceAuditEventRepository,
  AlertExplanationRepository,
  ChecklistInstanceRepository,
  ChecklistTemplateRepository,
  EpisodeOfCareEncounterRepository,
  HandoffTaskRepository,
  TaskRepository,
  CarePlanTaskRepository,
} from "@cuur-cde/core/workflow-care-pathways/repositories/index.js";
import type {
  Alert,
  AlertAuditEvent,
  AlertExplanation,
  CarePathwayTemplate,
  CarePathwayTemplateOrderSetTemplate,
  CarePathwayTemplateStep,
  CarePlan,
  CarePlanChecklist,
  CarePlanGoal,
  CarePlanTask,
  ChecklistInstance,
  ChecklistInstanceItem,
  ChecklistTemplate,
  ChecklistTemplateItem,
  EpisodeOfCareCarePlan,
  EpisodeOfCareEncounter,
  EpisodeOfCareWorkflowInstance,
  EpisodesOfCare,
  EscalationPolicy,
  EscalationPolicyRule,
  Handoff,
  HandoffTask,
  RoutingRule,
  ScheduleTemplate,
  Task,
  TaskAssignment,
  TaskAuditEvent,
  TaskComment,
  WorkQueue,
  WorkQueueAlert,
  WorkQueueTask,
  WorkflowDefinition,
  WorkflowDefinitionState,
  WorkflowDefinitionTransition,
  WorkflowInstance,
  WorkflowInstanceAuditEvent,
  WorkflowInstanceEvent,
  WorkflowInstanceTask,
  AlertInput,
  CarePathwayTemplateInput,
  CarePlanInput,
  ChecklistInstanceInput,
  ChecklistTemplateInput,
  EscalationPolicyInput,
  HandoffInput,
  RoutingRuleInput,
  ScheduleTemplateInput,
  TaskAssignmentInput,
  TaskInput,
  WorkQueueInput,
  WorkflowDefinitionInput,
  WorkflowInstanceInput,
  AlertUpdate,
  CarePathwayTemplateUpdate,
  CarePlanUpdate,
  ChecklistInstanceUpdate,
  ChecklistTemplateUpdate,
  EscalationPolicyUpdate,
  HandoffUpdate,
  RoutingRuleUpdate,
  ScheduleTemplateUpdate,
  TaskAssignmentUpdate,
  TaskUpdate,
  WorkQueueUpdate,
  WorkflowDefinitionUpdate,
  WorkflowInstanceUpdate,
} from "@cuur-cde/core/workflow-care-pathways/types/index.js";
import type {
  ListAlertsParams,
  ListCarePathwayTemplatesParams,
  ListCarePlansParams,
  ListChecklistInstancesParams,
  ListChecklistTemplatesParams,
  ListEpisodesOfCareParams,
  ListEscalationPoliciesParams,
  ListHandoffsParams,
  ListRoutingRulesParams,
  ListScheduleTemplatesParams,
  ListTaskAssignmentsParams,
  ListTasksParams,
  ListWorkQueuesParams,
  ListWorkflowDefinitionsParams,
  ListWorkflowInstancesParams,
  PaginationParams,
  PaginatedResult,
} from "@cuur-cde/core/shared/helpers/index.js";
import { wcTransactionId } from "@cuur-cde/core/shared/helpers/id-generator.js";


/**
 * Mock WorkQueueRepository for testing
 */export class MockWorkQueueRepository implements WorkQueueRepository {
  private workQueues: WorkQueue[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.workQueues = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListWorkQueuesParams
  ): Promise<PaginatedResult<WorkQueue>> {
    let items = this.workQueues.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<WorkQueue | null> {
    return this.workQueues.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<WorkQueue | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: WorkQueueInput): Promise<WorkQueue> {
    const workQueue: WorkQueue = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as WorkQueue;
    this.workQueues.push(workQueue);
    return workQueue;
  }

  async update(orgId: string, id: string, data: WorkQueueUpdate): Promise<WorkQueue> {
    const workQueue = await this.findById(orgId, id);
    if (!workQueue) {
      throw new Error(`WorkQueue ${id} not found`);
    }
    Object.assign(workQueue, data, { updatedAt: new Date() });
    return workQueue;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.workQueues.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`WorkQueue ${id} not found`);
    }
    this.workQueues.splice(index, 1);
  }
}

/**
 * Mock WorkflowDefinitionTransitionRepository for testing
 */export class MockWorkflowDefinitionTransitionRepository implements WorkflowDefinitionTransitionRepository {
  private workflowDefinitionTransitions: WorkflowDefinitionTransition[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.workflowDefinitionTransitions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<WorkflowDefinitionTransition>> {
    let items = this.workflowDefinitionTransitions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<WorkflowDefinitionTransition | null> {
    return this.workflowDefinitionTransitions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<WorkflowDefinitionTransition | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock WorkflowDefinitionStateRepository for testing
 */export class MockWorkflowDefinitionStateRepository implements WorkflowDefinitionStateRepository {
  private workflowDefinitionStates: WorkflowDefinitionState[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.workflowDefinitionStates = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<WorkflowDefinitionState>> {
    let items = this.workflowDefinitionStates.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<WorkflowDefinitionState | null> {
    return this.workflowDefinitionStates.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<WorkflowDefinitionState | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock TaskCommentRepository for testing
 */export class MockTaskCommentRepository implements TaskCommentRepository {
  private taskComments: TaskComment[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.taskComments = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<TaskComment>> {
    let items = this.taskComments.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<TaskComment | null> {
    return this.taskComments.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<TaskComment | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock CarePathwayTemplateOrderSetTemplateRepository for testing
 */export class MockCarePathwayTemplateOrderSetTemplateRepository implements CarePathwayTemplateOrderSetTemplateRepository {
  private carePathwayTemplateOrderSetTemplates: CarePathwayTemplateOrderSetTemplate[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.carePathwayTemplateOrderSetTemplates = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<CarePathwayTemplateOrderSetTemplate>> {
    let items = this.carePathwayTemplateOrderSetTemplates.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CarePathwayTemplateOrderSetTemplate | null> {
    return this.carePathwayTemplateOrderSetTemplates.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CarePathwayTemplateOrderSetTemplate | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock AlertRepository for testing
 */export class MockAlertRepository implements AlertRepository {
  private alerts: Alert[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.alerts = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListAlertsParams
  ): Promise<PaginatedResult<Alert>> {
    let items = this.alerts.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Alert | null> {
    return this.alerts.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Alert | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: AlertInput): Promise<Alert> {
    const alert: Alert = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Alert;
    this.alerts.push(alert);
    return alert;
  }

  async update(orgId: string, id: string, data: AlertUpdate): Promise<Alert> {
    const alert = await this.findById(orgId, id);
    if (!alert) {
      throw new Error(`Alert ${id} not found`);
    }
    Object.assign(alert, data, { updatedAt: new Date() });
    return alert;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.alerts.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Alert ${id} not found`);
    }
    this.alerts.splice(index, 1);
  }
}

/**
 * Mock WorkflowInstanceRepository for testing
 */export class MockWorkflowInstanceRepository implements WorkflowInstanceRepository {
  private workflowInstances: WorkflowInstance[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.workflowInstances = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListWorkflowInstancesParams
  ): Promise<PaginatedResult<WorkflowInstance>> {
    let items = this.workflowInstances.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<WorkflowInstance | null> {
    return this.workflowInstances.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<WorkflowInstance | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: WorkflowInstanceInput): Promise<WorkflowInstance> {
    const workflowInstance: WorkflowInstance = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as WorkflowInstance;
    this.workflowInstances.push(workflowInstance);
    return workflowInstance;
  }

  async update(orgId: string, id: string, data: WorkflowInstanceUpdate): Promise<WorkflowInstance> {
    const workflowInstance = await this.findById(orgId, id);
    if (!workflowInstance) {
      throw new Error(`WorkflowInstance ${id} not found`);
    }
    Object.assign(workflowInstance, data, { updatedAt: new Date() });
    return workflowInstance;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.workflowInstances.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`WorkflowInstance ${id} not found`);
    }
    this.workflowInstances.splice(index, 1);
  }
}

/**
 * Mock EscalationPolicyRepository for testing
 */export class MockEscalationPolicyRepository implements EscalationPolicyRepository {
  private escalationPolicys: EscalationPolicy[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.escalationPolicys = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListEscalationPoliciesParams
  ): Promise<PaginatedResult<EscalationPolicy>> {
    let items = this.escalationPolicys.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EscalationPolicy | null> {
    return this.escalationPolicys.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EscalationPolicy | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: EscalationPolicyInput): Promise<EscalationPolicy> {
    const escalationPolicy: EscalationPolicy = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as EscalationPolicy;
    this.escalationPolicys.push(escalationPolicy);
    return escalationPolicy;
  }

  async update(orgId: string, id: string, data: EscalationPolicyUpdate): Promise<EscalationPolicy> {
    const escalationPolicy = await this.findById(orgId, id);
    if (!escalationPolicy) {
      throw new Error(`EscalationPolicy ${id} not found`);
    }
    Object.assign(escalationPolicy, data, { updatedAt: new Date() });
    return escalationPolicy;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.escalationPolicys.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`EscalationPolicy ${id} not found`);
    }
    this.escalationPolicys.splice(index, 1);
  }
}

/**
 * Mock EpisodeOfCareWorkflowInstanceRepository for testing
 */export class MockEpisodeOfCareWorkflowInstanceRepository implements EpisodeOfCareWorkflowInstanceRepository {
  private episodeOfCareWorkflowInstances: EpisodeOfCareWorkflowInstance[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.episodeOfCareWorkflowInstances = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<EpisodeOfCareWorkflowInstance>> {
    let items = this.episodeOfCareWorkflowInstances.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EpisodeOfCareWorkflowInstance | null> {
    return this.episodeOfCareWorkflowInstances.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EpisodeOfCareWorkflowInstance | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock TaskAssignmentRepository for testing
 */export class MockTaskAssignmentRepository implements TaskAssignmentRepository {
  private taskAssignments: TaskAssignment[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.taskAssignments = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListTaskAssignmentsParams
  ): Promise<PaginatedResult<TaskAssignment>> {
    let items = this.taskAssignments.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<TaskAssignment | null> {
    return this.taskAssignments.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<TaskAssignment | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: TaskAssignmentInput): Promise<TaskAssignment> {
    const taskAssignment: TaskAssignment = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as TaskAssignment;
    this.taskAssignments.push(taskAssignment);
    return taskAssignment;
  }

  async update(orgId: string, id: string, data: TaskAssignmentUpdate): Promise<TaskAssignment> {
    const taskAssignment = await this.findById(orgId, id);
    if (!taskAssignment) {
      throw new Error(`TaskAssignment ${id} not found`);
    }
    Object.assign(taskAssignment, data, { updatedAt: new Date() });
    return taskAssignment;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.taskAssignments.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`TaskAssignment ${id} not found`);
    }
    this.taskAssignments.splice(index, 1);
  }
}

/**
 * Mock ChecklistTemplateItemRepository for testing
 */export class MockChecklistTemplateItemRepository implements ChecklistTemplateItemRepository {
  private checklistTemplateItems: ChecklistTemplateItem[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.checklistTemplateItems = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ChecklistTemplateItem>> {
    let items = this.checklistTemplateItems.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ChecklistTemplateItem | null> {
    return this.checklistTemplateItems.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ChecklistTemplateItem | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock WorkflowDefinitionRepository for testing
 */export class MockWorkflowDefinitionRepository implements WorkflowDefinitionRepository {
  private workflowDefinitions: WorkflowDefinition[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.workflowDefinitions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListWorkflowDefinitionsParams
  ): Promise<PaginatedResult<WorkflowDefinition>> {
    let items = this.workflowDefinitions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<WorkflowDefinition | null> {
    return this.workflowDefinitions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<WorkflowDefinition | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: WorkflowDefinitionInput): Promise<WorkflowDefinition> {
    const workflowDefinition: WorkflowDefinition = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as WorkflowDefinition;
    this.workflowDefinitions.push(workflowDefinition);
    return workflowDefinition;
  }

  async update(orgId: string, id: string, data: WorkflowDefinitionUpdate): Promise<WorkflowDefinition> {
    const workflowDefinition = await this.findById(orgId, id);
    if (!workflowDefinition) {
      throw new Error(`WorkflowDefinition ${id} not found`);
    }
    Object.assign(workflowDefinition, data, { updatedAt: new Date() });
    return workflowDefinition;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.workflowDefinitions.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`WorkflowDefinition ${id} not found`);
    }
    this.workflowDefinitions.splice(index, 1);
  }
}

/**
 * Mock EpisodesOfCareRepository for testing
 */export class MockEpisodesOfCareRepository implements EpisodesOfCareRepository {
  private episodesOfCares: EpisodesOfCare[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.episodesOfCares = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListEpisodesOfCareParams
  ): Promise<PaginatedResult<EpisodesOfCare>> {
    let items = this.episodesOfCares.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EpisodesOfCare | null> {
    return this.episodesOfCares.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EpisodesOfCare | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock CarePlanGoalRepository for testing
 */export class MockCarePlanGoalRepository implements CarePlanGoalRepository {
  private carePlanGoals: CarePlanGoal[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.carePlanGoals = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<CarePlanGoal>> {
    let items = this.carePlanGoals.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CarePlanGoal | null> {
    return this.carePlanGoals.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CarePlanGoal | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock HandoffRepository for testing
 */export class MockHandoffRepository implements HandoffRepository {
  private handoffs: Handoff[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.handoffs = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListHandoffsParams
  ): Promise<PaginatedResult<Handoff>> {
    let items = this.handoffs.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Handoff | null> {
    return this.handoffs.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Handoff | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: HandoffInput): Promise<Handoff> {
    const handoff: Handoff = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Handoff;
    this.handoffs.push(handoff);
    return handoff;
  }

  async update(orgId: string, id: string, data: HandoffUpdate): Promise<Handoff> {
    const handoff = await this.findById(orgId, id);
    if (!handoff) {
      throw new Error(`Handoff ${id} not found`);
    }
    Object.assign(handoff, data, { updatedAt: new Date() });
    return handoff;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.handoffs.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Handoff ${id} not found`);
    }
    this.handoffs.splice(index, 1);
  }
}

/**
 * Mock AlertAuditEventRepository for testing
 */export class MockAlertAuditEventRepository implements AlertAuditEventRepository {
  private alertAuditEvents: AlertAuditEvent[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.alertAuditEvents = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<AlertAuditEvent>> {
    let items = this.alertAuditEvents.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<AlertAuditEvent | null> {
    return this.alertAuditEvents.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<AlertAuditEvent | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock RoutingRuleRepository for testing
 */export class MockRoutingRuleRepository implements RoutingRuleRepository {
  private routingRules: RoutingRule[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.routingRules = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListRoutingRulesParams
  ): Promise<PaginatedResult<RoutingRule>> {
    let items = this.routingRules.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<RoutingRule | null> {
    return this.routingRules.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<RoutingRule | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: RoutingRuleInput): Promise<RoutingRule> {
    const routingRule: RoutingRule = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as RoutingRule;
    this.routingRules.push(routingRule);
    return routingRule;
  }

  async update(orgId: string, id: string, data: RoutingRuleUpdate): Promise<RoutingRule> {
    const routingRule = await this.findById(orgId, id);
    if (!routingRule) {
      throw new Error(`RoutingRule ${id} not found`);
    }
    Object.assign(routingRule, data, { updatedAt: new Date() });
    return routingRule;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.routingRules.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`RoutingRule ${id} not found`);
    }
    this.routingRules.splice(index, 1);
  }
}

/**
 * Mock TaskAuditEventRepository for testing
 */export class MockTaskAuditEventRepository implements TaskAuditEventRepository {
  private taskAuditEvents: TaskAuditEvent[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.taskAuditEvents = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<TaskAuditEvent>> {
    let items = this.taskAuditEvents.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<TaskAuditEvent | null> {
    return this.taskAuditEvents.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<TaskAuditEvent | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock EpisodeOfCareCarePlanRepository for testing
 */export class MockEpisodeOfCareCarePlanRepository implements EpisodeOfCareCarePlanRepository {
  private episodeOfCareCarePlans: EpisodeOfCareCarePlan[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.episodeOfCareCarePlans = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<EpisodeOfCareCarePlan>> {
    let items = this.episodeOfCareCarePlans.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EpisodeOfCareCarePlan | null> {
    return this.episodeOfCareCarePlans.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EpisodeOfCareCarePlan | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock CarePlanChecklistRepository for testing
 */export class MockCarePlanChecklistRepository implements CarePlanChecklistRepository {
  private carePlanChecklists: CarePlanChecklist[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.carePlanChecklists = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<CarePlanChecklist>> {
    let items = this.carePlanChecklists.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CarePlanChecklist | null> {
    return this.carePlanChecklists.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CarePlanChecklist | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock WorkQueueAlertRepository for testing
 */export class MockWorkQueueAlertRepository implements WorkQueueAlertRepository {
  private workQueueAlerts: WorkQueueAlert[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.workQueueAlerts = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<WorkQueueAlert>> {
    let items = this.workQueueAlerts.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<WorkQueueAlert | null> {
    return this.workQueueAlerts.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<WorkQueueAlert | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock CarePathwayTemplateStepRepository for testing
 */export class MockCarePathwayTemplateStepRepository implements CarePathwayTemplateStepRepository {
  private carePathwayTemplateSteps: CarePathwayTemplateStep[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.carePathwayTemplateSteps = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<CarePathwayTemplateStep>> {
    let items = this.carePathwayTemplateSteps.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CarePathwayTemplateStep | null> {
    return this.carePathwayTemplateSteps.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CarePathwayTemplateStep | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock CarePlanRepository for testing
 */export class MockCarePlanRepository implements CarePlanRepository {
  private carePlans: CarePlan[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.carePlans = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListCarePlansParams
  ): Promise<PaginatedResult<CarePlan>> {
    let items = this.carePlans.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CarePlan | null> {
    return this.carePlans.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CarePlan | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CarePlanInput): Promise<CarePlan> {
    const carePlan: CarePlan = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as CarePlan;
    this.carePlans.push(carePlan);
    return carePlan;
  }

  async update(orgId: string, id: string, data: CarePlanUpdate): Promise<CarePlan> {
    const carePlan = await this.findById(orgId, id);
    if (!carePlan) {
      throw new Error(`CarePlan ${id} not found`);
    }
    Object.assign(carePlan, data, { updatedAt: new Date() });
    return carePlan;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.carePlans.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`CarePlan ${id} not found`);
    }
    this.carePlans.splice(index, 1);
  }
}

/**
 * Mock WorkflowInstanceTaskRepository for testing
 */export class MockWorkflowInstanceTaskRepository implements WorkflowInstanceTaskRepository {
  private workflowInstanceTasks: WorkflowInstanceTask[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.workflowInstanceTasks = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<WorkflowInstanceTask>> {
    let items = this.workflowInstanceTasks.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<WorkflowInstanceTask | null> {
    return this.workflowInstanceTasks.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<WorkflowInstanceTask | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock WorkflowInstanceEventRepository for testing
 */export class MockWorkflowInstanceEventRepository implements WorkflowInstanceEventRepository {
  private workflowInstanceEvents: WorkflowInstanceEvent[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.workflowInstanceEvents = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<WorkflowInstanceEvent>> {
    let items = this.workflowInstanceEvents.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<WorkflowInstanceEvent | null> {
    return this.workflowInstanceEvents.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<WorkflowInstanceEvent | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ScheduleTemplateRepository for testing
 */export class MockScheduleTemplateRepository implements ScheduleTemplateRepository {
  private scheduleTemplates: ScheduleTemplate[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.scheduleTemplates = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListScheduleTemplatesParams
  ): Promise<PaginatedResult<ScheduleTemplate>> {
    let items = this.scheduleTemplates.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ScheduleTemplate | null> {
    return this.scheduleTemplates.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ScheduleTemplate | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ScheduleTemplateInput): Promise<ScheduleTemplate> {
    const scheduleTemplate: ScheduleTemplate = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ScheduleTemplate;
    this.scheduleTemplates.push(scheduleTemplate);
    return scheduleTemplate;
  }

  async update(orgId: string, id: string, data: ScheduleTemplateUpdate): Promise<ScheduleTemplate> {
    const scheduleTemplate = await this.findById(orgId, id);
    if (!scheduleTemplate) {
      throw new Error(`ScheduleTemplate ${id} not found`);
    }
    Object.assign(scheduleTemplate, data, { updatedAt: new Date() });
    return scheduleTemplate;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.scheduleTemplates.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ScheduleTemplate ${id} not found`);
    }
    this.scheduleTemplates.splice(index, 1);
  }
}

/**
 * Mock EscalationPolicyRuleRepository for testing
 */export class MockEscalationPolicyRuleRepository implements EscalationPolicyRuleRepository {
  private escalationPolicyRules: EscalationPolicyRule[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.escalationPolicyRules = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<EscalationPolicyRule>> {
    let items = this.escalationPolicyRules.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EscalationPolicyRule | null> {
    return this.escalationPolicyRules.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EscalationPolicyRule | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock CarePathwayTemplateRepository for testing
 */export class MockCarePathwayTemplateRepository implements CarePathwayTemplateRepository {
  private carePathwayTemplates: CarePathwayTemplate[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.carePathwayTemplates = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListCarePathwayTemplatesParams
  ): Promise<PaginatedResult<CarePathwayTemplate>> {
    let items = this.carePathwayTemplates.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CarePathwayTemplate | null> {
    return this.carePathwayTemplates.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CarePathwayTemplate | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CarePathwayTemplateInput): Promise<CarePathwayTemplate> {
    const carePathwayTemplate: CarePathwayTemplate = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as CarePathwayTemplate;
    this.carePathwayTemplates.push(carePathwayTemplate);
    return carePathwayTemplate;
  }

  async update(orgId: string, id: string, data: CarePathwayTemplateUpdate): Promise<CarePathwayTemplate> {
    const carePathwayTemplate = await this.findById(orgId, id);
    if (!carePathwayTemplate) {
      throw new Error(`CarePathwayTemplate ${id} not found`);
    }
    Object.assign(carePathwayTemplate, data, { updatedAt: new Date() });
    return carePathwayTemplate;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.carePathwayTemplates.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`CarePathwayTemplate ${id} not found`);
    }
    this.carePathwayTemplates.splice(index, 1);
  }
}

/**
 * Mock ChecklistInstanceItemRepository for testing
 */export class MockChecklistInstanceItemRepository implements ChecklistInstanceItemRepository {
  private checklistInstanceItems: ChecklistInstanceItem[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.checklistInstanceItems = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ChecklistInstanceItem>> {
    let items = this.checklistInstanceItems.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ChecklistInstanceItem | null> {
    return this.checklistInstanceItems.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ChecklistInstanceItem | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock WorkQueueTaskRepository for testing
 */export class MockWorkQueueTaskRepository implements WorkQueueTaskRepository {
  private workQueueTasks: WorkQueueTask[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.workQueueTasks = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<WorkQueueTask>> {
    let items = this.workQueueTasks.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<WorkQueueTask | null> {
    return this.workQueueTasks.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<WorkQueueTask | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock WorkflowInstanceAuditEventRepository for testing
 */export class MockWorkflowInstanceAuditEventRepository implements WorkflowInstanceAuditEventRepository {
  private workflowInstanceAuditEvents: WorkflowInstanceAuditEvent[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.workflowInstanceAuditEvents = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<WorkflowInstanceAuditEvent>> {
    let items = this.workflowInstanceAuditEvents.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<WorkflowInstanceAuditEvent | null> {
    return this.workflowInstanceAuditEvents.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<WorkflowInstanceAuditEvent | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock AlertExplanationRepository for testing
 */export class MockAlertExplanationRepository implements AlertExplanationRepository {
  private alertExplanations: AlertExplanation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.alertExplanations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<AlertExplanation>> {
    let items = this.alertExplanations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<AlertExplanation | null> {
    return this.alertExplanations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<AlertExplanation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ChecklistInstanceRepository for testing
 */export class MockChecklistInstanceRepository implements ChecklistInstanceRepository {
  private checklistInstances: ChecklistInstance[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.checklistInstances = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListChecklistInstancesParams
  ): Promise<PaginatedResult<ChecklistInstance>> {
    let items = this.checklistInstances.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ChecklistInstance | null> {
    return this.checklistInstances.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ChecklistInstance | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ChecklistInstanceInput): Promise<ChecklistInstance> {
    const checklistInstance: ChecklistInstance = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ChecklistInstance;
    this.checklistInstances.push(checklistInstance);
    return checklistInstance;
  }

  async update(orgId: string, id: string, data: ChecklistInstanceUpdate): Promise<ChecklistInstance> {
    const checklistInstance = await this.findById(orgId, id);
    if (!checklistInstance) {
      throw new Error(`ChecklistInstance ${id} not found`);
    }
    Object.assign(checklistInstance, data, { updatedAt: new Date() });
    return checklistInstance;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.checklistInstances.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ChecklistInstance ${id} not found`);
    }
    this.checklistInstances.splice(index, 1);
  }
}

/**
 * Mock ChecklistTemplateRepository for testing
 */export class MockChecklistTemplateRepository implements ChecklistTemplateRepository {
  private checklistTemplates: ChecklistTemplate[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.checklistTemplates = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListChecklistTemplatesParams
  ): Promise<PaginatedResult<ChecklistTemplate>> {
    let items = this.checklistTemplates.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ChecklistTemplate | null> {
    return this.checklistTemplates.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ChecklistTemplate | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ChecklistTemplateInput): Promise<ChecklistTemplate> {
    const checklistTemplate: ChecklistTemplate = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ChecklistTemplate;
    this.checklistTemplates.push(checklistTemplate);
    return checklistTemplate;
  }

  async update(orgId: string, id: string, data: ChecklistTemplateUpdate): Promise<ChecklistTemplate> {
    const checklistTemplate = await this.findById(orgId, id);
    if (!checklistTemplate) {
      throw new Error(`ChecklistTemplate ${id} not found`);
    }
    Object.assign(checklistTemplate, data, { updatedAt: new Date() });
    return checklistTemplate;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.checklistTemplates.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ChecklistTemplate ${id} not found`);
    }
    this.checklistTemplates.splice(index, 1);
  }
}

/**
 * Mock EpisodeOfCareEncounterRepository for testing
 */export class MockEpisodeOfCareEncounterRepository implements EpisodeOfCareEncounterRepository {
  private episodeOfCareEncounters: EpisodeOfCareEncounter[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.episodeOfCareEncounters = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<EpisodeOfCareEncounter>> {
    let items = this.episodeOfCareEncounters.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<EpisodeOfCareEncounter | null> {
    return this.episodeOfCareEncounters.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<EpisodeOfCareEncounter | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock HandoffTaskRepository for testing
 */export class MockHandoffTaskRepository implements HandoffTaskRepository {
  private handoffTasks: HandoffTask[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.handoffTasks = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<HandoffTask>> {
    let items = this.handoffTasks.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<HandoffTask | null> {
    return this.handoffTasks.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<HandoffTask | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock TaskRepository for testing
 */export class MockTaskRepository implements TaskRepository {
  private tasks: Task[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.tasks = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListTasksParams
  ): Promise<PaginatedResult<Task>> {
    let items = this.tasks.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Task | null> {
    return this.tasks.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Task | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: TaskInput): Promise<Task> {
    const task: Task = {
      ...data,
      id: wcTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Task;
    this.tasks.push(task);
    return task;
  }

  async update(orgId: string, id: string, data: TaskUpdate): Promise<Task> {
    const task = await this.findById(orgId, id);
    if (!task) {
      throw new Error(`Task ${id} not found`);
    }
    Object.assign(task, data, { updatedAt: new Date() });
    return task;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.tasks.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Task ${id} not found`);
    }
    this.tasks.splice(index, 1);
  }
}

/**
 * Mock CarePlanTaskRepository for testing
 */export class MockCarePlanTaskRepository implements CarePlanTaskRepository {
  private carePlanTasks: CarePlanTask[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.carePlanTasks = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<CarePlanTask>> {
    let items = this.carePlanTasks.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<CarePlanTask | null> {
    return this.carePlanTasks.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<CarePlanTask | null> {
    return this.findById(orgId, id);
  }
}

