/**
 * Mock Repositories for Testing
 *
 * Generated by Test Generator v1.0.0
 * Generator Version: 1.0.0
 * Domain: decision-intelligence
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated. Any manual changes will be overwritten.
 */

import type {
  RiskAssessmentRepository,
  ExplanationFeatureRepository,
  DecisionSessionAlertRepository,
  DecisionPolicyThresholdProfileRepository,
  ExplanationRepository,
  ThresholdProfileRepository,
  DecisionRequestResultRepository,
  ExperimentResultRepository,
  DecisionResultExplanationRepository,
  ExperimentRepository,
  DecisionResultRiskAssessmentRepository,
  DecisionSessionRiskAssessmentRepository,
  DecisionSessionExplanationRepository,
  SimulationScenarioRepository,
  DecisionPolicyRepository,
  DecisionRequestExplanationRepository,
  SimulationRunRepository,
  DecisionRequestRepository,
  SimulationScenarioRunRepository,
  DecisionSessionRepository,
  DecisionSessionRequestRepository,
  DecisionResultRecommendationRepository,
  ExperimentArmRepository,
  ExplanationRuleTraceRepository,
  RecommendationRepository,
  DecisionResultRepository,
  AlertEvaluationRepository,
  DecisionSessionResultRepository,
  SimulationRunDecisionResultRepository,
  SimulationRunMetricRepository,
  ModelInvocationExplanationRepository,
  ModelInvocationRepository,
  RecommendationExplanationRepository,
  RiskAssessmentExplanationRepository,
  DecisionMetricRepository,
} from "@cuur-cde/core/decision-intelligence/repositories/index.js";
import type {
  AlertEvaluation,
  DecisionMetric,
  DecisionPolicy,
  DecisionPolicyThresholdProfile,
  DecisionRequest,
  DecisionRequestExplanation,
  DecisionRequestResult,
  DecisionResult,
  DecisionResultExplanation,
  DecisionResultRecommendation,
  DecisionResultRiskAssessment,
  DecisionSession,
  DecisionSessionAlert,
  DecisionSessionExplanation,
  DecisionSessionRequest,
  DecisionSessionResult,
  DecisionSessionRiskAssessment,
  Experiment,
  ExperimentArm,
  ExperimentResult,
  Explanation,
  ExplanationFeature,
  ExplanationRuleTrace,
  ModelInvocation,
  ModelInvocationExplanation,
  Recommendation,
  RecommendationExplanation,
  RiskAssessment,
  RiskAssessmentExplanation,
  SimulationRun,
  SimulationRunDecisionResult,
  SimulationRunMetric,
  SimulationScenario,
  SimulationScenarioRun,
  ThresholdProfile,
  AlertEvaluationInput,
  DecisionPolicyInput,
  DecisionResultInput,
  DecisionSessionInput,
  ExperimentInput,
  RecommendationInput,
  RiskAssessmentInput,
  SimulationScenarioInput,
  ThresholdProfileInput,
  AlertEvaluationUpdate,
  DecisionPolicyUpdate,
  DecisionResultUpdate,
  DecisionSessionUpdate,
  ExperimentUpdate,
  RecommendationUpdate,
  RiskAssessmentUpdate,
  SimulationScenarioUpdate,
  ThresholdProfileUpdate,
} from "@cuur-cde/core/decision-intelligence/types/index.js";
import type {
  ListAlertEvaluationsParams,
  ListDecisionMetricsParams,
  ListDecisionPoliciesParams,
  ListDecisionResultsParams,
  ListDecisionSessionsParams,
  ListExperimentsParams,
  ListRecommendationsParams,
  ListRiskAssessmentsParams,
  ListSimulationScenariosParams,
  ListThresholdProfilesParams,
  PaginationParams,
  PaginatedResult,
} from "@cuur-cde/core/_shared";
import { diTransactionId } from "@cuur-cde/core/_shared/id-generator.js";


/**
 * Mock RiskAssessmentRepository for testing
 */export class MockRiskAssessmentRepository implements RiskAssessmentRepository {
  private riskAssessments: RiskAssessment[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.riskAssessments = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListRiskAssessmentsParams
  ): Promise<PaginatedResult<RiskAssessment>> {
    let items = this.riskAssessments.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<RiskAssessment | null> {
    return this.riskAssessments.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<RiskAssessment | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: RiskAssessmentInput): Promise<RiskAssessment> {
    const riskAssessment: RiskAssessment = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as RiskAssessment;
    this.riskAssessments.push(riskAssessment);
    return riskAssessment;
  }

  async update(orgId: string, id: string, data: RiskAssessmentUpdate): Promise<RiskAssessment> {
    const riskAssessment = await this.findById(orgId, id);
    if (!riskAssessment) {
      throw new Error(`RiskAssessment ${id} not found`);
    }
    Object.assign(riskAssessment, data, { updatedAt: new Date() });
    return riskAssessment;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.riskAssessments.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`RiskAssessment ${id} not found`);
    }
    this.riskAssessments.splice(index, 1);
  }
}

/**
 * Mock ExplanationFeatureRepository for testing
 */export class MockExplanationFeatureRepository implements ExplanationFeatureRepository {
  private explanationFeatures: ExplanationFeature[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.explanationFeatures = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ExplanationFeature>> {
    let items = this.explanationFeatures.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ExplanationFeature | null> {
    return this.explanationFeatures.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ExplanationFeature | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DecisionSessionAlertRepository for testing
 */export class MockDecisionSessionAlertRepository implements DecisionSessionAlertRepository {
  private decisionSessionAlerts: DecisionSessionAlert[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionSessionAlerts = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionSessionAlert>> {
    let items = this.decisionSessionAlerts.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionSessionAlert | null> {
    return this.decisionSessionAlerts.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionSessionAlert | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DecisionPolicyThresholdProfileRepository for testing
 */export class MockDecisionPolicyThresholdProfileRepository implements DecisionPolicyThresholdProfileRepository {
  private decisionPolicyThresholdProfiles: DecisionPolicyThresholdProfile[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionPolicyThresholdProfiles = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionPolicyThresholdProfile>> {
    let items = this.decisionPolicyThresholdProfiles.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionPolicyThresholdProfile | null> {
    return this.decisionPolicyThresholdProfiles.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionPolicyThresholdProfile | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ExplanationRepository for testing
 */export class MockExplanationRepository implements ExplanationRepository {
  private explanations: Explanation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.explanations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: string
  ): Promise<PaginatedResult<Explanation>> {
    let items = this.explanations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Explanation | null> {
    return this.explanations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Explanation | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CreateExplanationRequest): Promise<Explanation> {
    const explanation: Explanation = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Explanation;
    this.explanations.push(explanation);
    return explanation;
  }
}

/**
 * Mock ThresholdProfileRepository for testing
 */export class MockThresholdProfileRepository implements ThresholdProfileRepository {
  private thresholdProfiles: ThresholdProfile[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.thresholdProfiles = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListThresholdProfilesParams
  ): Promise<PaginatedResult<ThresholdProfile>> {
    let items = this.thresholdProfiles.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ThresholdProfile | null> {
    return this.thresholdProfiles.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ThresholdProfile | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ThresholdProfileInput): Promise<ThresholdProfile> {
    const thresholdProfile: ThresholdProfile = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ThresholdProfile;
    this.thresholdProfiles.push(thresholdProfile);
    return thresholdProfile;
  }

  async update(orgId: string, id: string, data: ThresholdProfileUpdate): Promise<ThresholdProfile> {
    const thresholdProfile = await this.findById(orgId, id);
    if (!thresholdProfile) {
      throw new Error(`ThresholdProfile ${id} not found`);
    }
    Object.assign(thresholdProfile, data, { updatedAt: new Date() });
    return thresholdProfile;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.thresholdProfiles.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`ThresholdProfile ${id} not found`);
    }
    this.thresholdProfiles.splice(index, 1);
  }
}

/**
 * Mock DecisionRequestResultRepository for testing
 */export class MockDecisionRequestResultRepository implements DecisionRequestResultRepository {
  private decisionRequestResults: DecisionRequestResult[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionRequestResults = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionRequestResult>> {
    let items = this.decisionRequestResults.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionRequestResult | null> {
    return this.decisionRequestResults.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionRequestResult | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ExperimentResultRepository for testing
 */export class MockExperimentResultRepository implements ExperimentResultRepository {
  private experimentResults: ExperimentResult[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.experimentResults = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ExperimentResult>> {
    let items = this.experimentResults.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ExperimentResult | null> {
    return this.experimentResults.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ExperimentResult | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DecisionResultExplanationRepository for testing
 */export class MockDecisionResultExplanationRepository implements DecisionResultExplanationRepository {
  private decisionResultExplanations: DecisionResultExplanation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionResultExplanations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionResultExplanation>> {
    let items = this.decisionResultExplanations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionResultExplanation | null> {
    return this.decisionResultExplanations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionResultExplanation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ExperimentRepository for testing
 */export class MockExperimentRepository implements ExperimentRepository {
  private experiments: Experiment[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.experiments = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListExperimentsParams
  ): Promise<PaginatedResult<Experiment>> {
    let items = this.experiments.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Experiment | null> {
    return this.experiments.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Experiment | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: ExperimentInput): Promise<Experiment> {
    const experiment: Experiment = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Experiment;
    this.experiments.push(experiment);
    return experiment;
  }

  async update(orgId: string, id: string, data: ExperimentUpdate): Promise<Experiment> {
    const experiment = await this.findById(orgId, id);
    if (!experiment) {
      throw new Error(`Experiment ${id} not found`);
    }
    Object.assign(experiment, data, { updatedAt: new Date() });
    return experiment;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.experiments.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Experiment ${id} not found`);
    }
    this.experiments.splice(index, 1);
  }
}

/**
 * Mock DecisionResultRiskAssessmentRepository for testing
 */export class MockDecisionResultRiskAssessmentRepository implements DecisionResultRiskAssessmentRepository {
  private decisionResultRiskAssessments: DecisionResultRiskAssessment[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionResultRiskAssessments = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionResultRiskAssessment>> {
    let items = this.decisionResultRiskAssessments.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionResultRiskAssessment | null> {
    return this.decisionResultRiskAssessments.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionResultRiskAssessment | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DecisionSessionRiskAssessmentRepository for testing
 */export class MockDecisionSessionRiskAssessmentRepository implements DecisionSessionRiskAssessmentRepository {
  private decisionSessionRiskAssessments: DecisionSessionRiskAssessment[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionSessionRiskAssessments = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionSessionRiskAssessment>> {
    let items = this.decisionSessionRiskAssessments.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionSessionRiskAssessment | null> {
    return this.decisionSessionRiskAssessments.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionSessionRiskAssessment | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DecisionSessionExplanationRepository for testing
 */export class MockDecisionSessionExplanationRepository implements DecisionSessionExplanationRepository {
  private decisionSessionExplanations: DecisionSessionExplanation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionSessionExplanations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionSessionExplanation>> {
    let items = this.decisionSessionExplanations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionSessionExplanation | null> {
    return this.decisionSessionExplanations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionSessionExplanation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock SimulationScenarioRepository for testing
 */export class MockSimulationScenarioRepository implements SimulationScenarioRepository {
  private simulationScenarios: SimulationScenario[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.simulationScenarios = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListSimulationScenariosParams
  ): Promise<PaginatedResult<SimulationScenario>> {
    let items = this.simulationScenarios.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<SimulationScenario | null> {
    return this.simulationScenarios.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<SimulationScenario | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: SimulationScenarioInput): Promise<SimulationScenario> {
    const simulationScenario: SimulationScenario = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as SimulationScenario;
    this.simulationScenarios.push(simulationScenario);
    return simulationScenario;
  }

  async update(orgId: string, id: string, data: SimulationScenarioUpdate): Promise<SimulationScenario> {
    const simulationScenario = await this.findById(orgId, id);
    if (!simulationScenario) {
      throw new Error(`SimulationScenario ${id} not found`);
    }
    Object.assign(simulationScenario, data, { updatedAt: new Date() });
    return simulationScenario;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.simulationScenarios.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`SimulationScenario ${id} not found`);
    }
    this.simulationScenarios.splice(index, 1);
  }
}

/**
 * Mock DecisionPolicyRepository for testing
 */export class MockDecisionPolicyRepository implements DecisionPolicyRepository {
  private decisionPolicys: DecisionPolicy[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionPolicys = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListDecisionPoliciesParams
  ): Promise<PaginatedResult<DecisionPolicy>> {
    let items = this.decisionPolicys.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionPolicy | null> {
    return this.decisionPolicys.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionPolicy | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: DecisionPolicyInput): Promise<DecisionPolicy> {
    const decisionPolicy: DecisionPolicy = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as DecisionPolicy;
    this.decisionPolicys.push(decisionPolicy);
    return decisionPolicy;
  }

  async update(orgId: string, id: string, data: DecisionPolicyUpdate): Promise<DecisionPolicy> {
    const decisionPolicy = await this.findById(orgId, id);
    if (!decisionPolicy) {
      throw new Error(`DecisionPolicy ${id} not found`);
    }
    Object.assign(decisionPolicy, data, { updatedAt: new Date() });
    return decisionPolicy;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.decisionPolicys.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`DecisionPolicy ${id} not found`);
    }
    this.decisionPolicys.splice(index, 1);
  }
}

/**
 * Mock DecisionRequestExplanationRepository for testing
 */export class MockDecisionRequestExplanationRepository implements DecisionRequestExplanationRepository {
  private decisionRequestExplanations: DecisionRequestExplanation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionRequestExplanations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionRequestExplanation>> {
    let items = this.decisionRequestExplanations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionRequestExplanation | null> {
    return this.decisionRequestExplanations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionRequestExplanation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock SimulationRunRepository for testing
 */export class MockSimulationRunRepository implements SimulationRunRepository {
  private simulationRuns: SimulationRun[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.simulationRuns = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: string
  ): Promise<PaginatedResult<SimulationRun>> {
    let items = this.simulationRuns.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<SimulationRun | null> {
    return this.simulationRuns.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<SimulationRun | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CreateSimulationRunRequest): Promise<SimulationRun> {
    const simulationRun: SimulationRun = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as SimulationRun;
    this.simulationRuns.push(simulationRun);
    return simulationRun;
  }
}

/**
 * Mock DecisionRequestRepository for testing
 */export class MockDecisionRequestRepository implements DecisionRequestRepository {
  private decisionRequests: DecisionRequest[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionRequests = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: string
  ): Promise<PaginatedResult<DecisionRequest>> {
    let items = this.decisionRequests.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionRequest | null> {
    return this.decisionRequests.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionRequest | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CreateDecisionRequestRequest): Promise<DecisionRequest> {
    const decisionRequest: DecisionRequest = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as DecisionRequest;
    this.decisionRequests.push(decisionRequest);
    return decisionRequest;
  }
}

/**
 * Mock SimulationScenarioRunRepository for testing
 */export class MockSimulationScenarioRunRepository implements SimulationScenarioRunRepository {
  private simulationScenarioRuns: SimulationScenarioRun[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.simulationScenarioRuns = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<SimulationScenarioRun>> {
    let items = this.simulationScenarioRuns.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<SimulationScenarioRun | null> {
    return this.simulationScenarioRuns.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<SimulationScenarioRun | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DecisionSessionRepository for testing
 */export class MockDecisionSessionRepository implements DecisionSessionRepository {
  private decisionSessions: DecisionSession[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionSessions = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListDecisionSessionsParams
  ): Promise<PaginatedResult<DecisionSession>> {
    let items = this.decisionSessions.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionSession | null> {
    return this.decisionSessions.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionSession | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: DecisionSessionInput): Promise<DecisionSession> {
    const decisionSession: DecisionSession = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as DecisionSession;
    this.decisionSessions.push(decisionSession);
    return decisionSession;
  }

  async update(orgId: string, id: string, data: DecisionSessionUpdate): Promise<DecisionSession> {
    const decisionSession = await this.findById(orgId, id);
    if (!decisionSession) {
      throw new Error(`DecisionSession ${id} not found`);
    }
    Object.assign(decisionSession, data, { updatedAt: new Date() });
    return decisionSession;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.decisionSessions.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`DecisionSession ${id} not found`);
    }
    this.decisionSessions.splice(index, 1);
  }
}

/**
 * Mock DecisionSessionRequestRepository for testing
 */export class MockDecisionSessionRequestRepository implements DecisionSessionRequestRepository {
  private decisionSessionRequests: DecisionSessionRequest[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionSessionRequests = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionSessionRequest>> {
    let items = this.decisionSessionRequests.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionSessionRequest | null> {
    return this.decisionSessionRequests.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionSessionRequest | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DecisionResultRecommendationRepository for testing
 */export class MockDecisionResultRecommendationRepository implements DecisionResultRecommendationRepository {
  private decisionResultRecommendations: DecisionResultRecommendation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionResultRecommendations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionResultRecommendation>> {
    let items = this.decisionResultRecommendations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionResultRecommendation | null> {
    return this.decisionResultRecommendations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionResultRecommendation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ExperimentArmRepository for testing
 */export class MockExperimentArmRepository implements ExperimentArmRepository {
  private experimentArms: ExperimentArm[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.experimentArms = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ExperimentArm>> {
    let items = this.experimentArms.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ExperimentArm | null> {
    return this.experimentArms.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ExperimentArm | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ExplanationRuleTraceRepository for testing
 */export class MockExplanationRuleTraceRepository implements ExplanationRuleTraceRepository {
  private explanationRuleTraces: ExplanationRuleTrace[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.explanationRuleTraces = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ExplanationRuleTrace>> {
    let items = this.explanationRuleTraces.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ExplanationRuleTrace | null> {
    return this.explanationRuleTraces.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ExplanationRuleTrace | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock RecommendationRepository for testing
 */export class MockRecommendationRepository implements RecommendationRepository {
  private recommendations: Recommendation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.recommendations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListRecommendationsParams
  ): Promise<PaginatedResult<Recommendation>> {
    let items = this.recommendations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<Recommendation | null> {
    return this.recommendations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<Recommendation | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: RecommendationInput): Promise<Recommendation> {
    const recommendation: Recommendation = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as Recommendation;
    this.recommendations.push(recommendation);
    return recommendation;
  }

  async update(orgId: string, id: string, data: RecommendationUpdate): Promise<Recommendation> {
    const recommendation = await this.findById(orgId, id);
    if (!recommendation) {
      throw new Error(`Recommendation ${id} not found`);
    }
    Object.assign(recommendation, data, { updatedAt: new Date() });
    return recommendation;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.recommendations.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`Recommendation ${id} not found`);
    }
    this.recommendations.splice(index, 1);
  }
}

/**
 * Mock DecisionResultRepository for testing
 */export class MockDecisionResultRepository implements DecisionResultRepository {
  private decisionResults: DecisionResult[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionResults = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListDecisionResultsParams
  ): Promise<PaginatedResult<DecisionResult>> {
    let items = this.decisionResults.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionResult | null> {
    return this.decisionResults.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionResult | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: DecisionResultInput): Promise<DecisionResult> {
    const decisionResult: DecisionResult = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as DecisionResult;
    this.decisionResults.push(decisionResult);
    return decisionResult;
  }

  async update(orgId: string, id: string, data: DecisionResultUpdate): Promise<DecisionResult> {
    const decisionResult = await this.findById(orgId, id);
    if (!decisionResult) {
      throw new Error(`DecisionResult ${id} not found`);
    }
    Object.assign(decisionResult, data, { updatedAt: new Date() });
    return decisionResult;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.decisionResults.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`DecisionResult ${id} not found`);
    }
    this.decisionResults.splice(index, 1);
  }
}

/**
 * Mock AlertEvaluationRepository for testing
 */export class MockAlertEvaluationRepository implements AlertEvaluationRepository {
  private alertEvaluations: AlertEvaluation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.alertEvaluations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListAlertEvaluationsParams
  ): Promise<PaginatedResult<AlertEvaluation>> {
    let items = this.alertEvaluations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<AlertEvaluation | null> {
    return this.alertEvaluations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<AlertEvaluation | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: AlertEvaluationInput): Promise<AlertEvaluation> {
    const alertEvaluation: AlertEvaluation = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as AlertEvaluation;
    this.alertEvaluations.push(alertEvaluation);
    return alertEvaluation;
  }

  async update(orgId: string, id: string, data: AlertEvaluationUpdate): Promise<AlertEvaluation> {
    const alertEvaluation = await this.findById(orgId, id);
    if (!alertEvaluation) {
      throw new Error(`AlertEvaluation ${id} not found`);
    }
    Object.assign(alertEvaluation, data, { updatedAt: new Date() });
    return alertEvaluation;
  }

  async delete(orgId: string, id: string): Promise<void> {
    const index = this.alertEvaluations.findIndex((item) => item.id === id && item.orgId === orgId);
    if (index === -1) {
      throw new Error(`AlertEvaluation ${id} not found`);
    }
    this.alertEvaluations.splice(index, 1);
  }
}

/**
 * Mock DecisionSessionResultRepository for testing
 */export class MockDecisionSessionResultRepository implements DecisionSessionResultRepository {
  private decisionSessionResults: DecisionSessionResult[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionSessionResults = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<DecisionSessionResult>> {
    let items = this.decisionSessionResults.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionSessionResult | null> {
    return this.decisionSessionResults.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionSessionResult | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock SimulationRunDecisionResultRepository for testing
 */export class MockSimulationRunDecisionResultRepository implements SimulationRunDecisionResultRepository {
  private simulationRunDecisionResults: SimulationRunDecisionResult[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.simulationRunDecisionResults = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<SimulationRunDecisionResult>> {
    let items = this.simulationRunDecisionResults.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<SimulationRunDecisionResult | null> {
    return this.simulationRunDecisionResults.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<SimulationRunDecisionResult | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock SimulationRunMetricRepository for testing
 */export class MockSimulationRunMetricRepository implements SimulationRunMetricRepository {
  private simulationRunMetrics: SimulationRunMetric[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.simulationRunMetrics = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<SimulationRunMetric>> {
    let items = this.simulationRunMetrics.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<SimulationRunMetric | null> {
    return this.simulationRunMetrics.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<SimulationRunMetric | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ModelInvocationExplanationRepository for testing
 */export class MockModelInvocationExplanationRepository implements ModelInvocationExplanationRepository {
  private modelInvocationExplanations: ModelInvocationExplanation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.modelInvocationExplanations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<ModelInvocationExplanation>> {
    let items = this.modelInvocationExplanations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ModelInvocationExplanation | null> {
    return this.modelInvocationExplanations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ModelInvocationExplanation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock ModelInvocationRepository for testing
 */export class MockModelInvocationRepository implements ModelInvocationRepository {
  private modelInvocations: ModelInvocation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.modelInvocations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: string
  ): Promise<PaginatedResult<ModelInvocation>> {
    let items = this.modelInvocations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<ModelInvocation | null> {
    return this.modelInvocations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<ModelInvocation | null> {
    return this.findById(orgId, id);
  }

  async create(orgId: string, data: CreateModelInvocationRequest): Promise<ModelInvocation> {
    const modelInvocation: ModelInvocation = {
      ...data,
      id: diTransactionId(),
      orgId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as ModelInvocation;
    this.modelInvocations.push(modelInvocation);
    return modelInvocation;
  }
}

/**
 * Mock RecommendationExplanationRepository for testing
 */export class MockRecommendationExplanationRepository implements RecommendationExplanationRepository {
  private recommendationExplanations: RecommendationExplanation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.recommendationExplanations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<RecommendationExplanation>> {
    let items = this.recommendationExplanations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<RecommendationExplanation | null> {
    return this.recommendationExplanations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<RecommendationExplanation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock RiskAssessmentExplanationRepository for testing
 */export class MockRiskAssessmentExplanationRepository implements RiskAssessmentExplanationRepository {
  private riskAssessmentExplanations: RiskAssessmentExplanation[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.riskAssessmentExplanations = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: PaginationParams
  ): Promise<PaginatedResult<RiskAssessmentExplanation>> {
    let items = this.riskAssessmentExplanations.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<RiskAssessmentExplanation | null> {
    return this.riskAssessmentExplanations.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<RiskAssessmentExplanation | null> {
    return this.findById(orgId, id);
  }
}

/**
 * Mock DecisionMetricRepository for testing
 */export class MockDecisionMetricRepository implements DecisionMetricRepository {
  private decisionMetrics: DecisionMetric[] = [];
  private idCounter = 1;

  /**
   * Reset mock state (call in beforeEach)
   */
  reset(): void {
    this.decisionMetrics = [];
    this.idCounter = 1;
  }

  async list(
    orgId: string,
    params?: ListDecisionMetricsParams
  ): Promise<PaginatedResult<DecisionMetric>> {
    let items = this.decisionMetrics.filter((item) => item.orgId === orgId);

    const limit = (params as any)?.limit ?? 50;
    if (limit) {
      items = items.slice(0, limit);
    }

    return {
      items,
      nextCursor: items.length === limit ? items[items.length - 1]?.id : undefined,
      prevCursor: undefined,
    };
  }

  async findById(orgId: string, id: string): Promise<DecisionMetric | null> {
    return this.decisionMetrics.find((item) => item.id === id && item.orgId === orgId) || null;
  }

  async get(orgId: string, id: string): Promise<DecisionMetric | null> {
    return this.findById(orgId, id);
  }
}

